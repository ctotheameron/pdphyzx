/**
 * pdphyzx.h - Playdate Physics Engine
 * Single-header version generated by build script
 */

#ifndef PDPHYZX_H
#define PDPHYZX_H

#include <stdint.h>
#include <assert.h>
#include <stdio.h>
#include <stdbool.h>
#include <float.h>
#include <stdlib.h>
#include <math.h>
#include <stddef.h>

#ifndef PlaydateAPI
typedef struct PlaydateAPI PlaydateAPI;
#endif

/**
 * @file px_math.h
 *
 * @brief This file contains mathematical functions and constants for the
 *        PDPHYZX library.
 *
 * The functions provided in this file include fast inverse square root,
 * reciprocal, division, square root, clamping, rounding, comparison, and random
 * number generation.
 */



#define PX_ONE_THIRD 0.333333333f
#define PX_EPSILON 0.0001f
#define PX_PI 3.141592741f
#define PX_2_PI PX_PI * 2.0f
#define PX_H_PI PX_PI * 0.5f
#define PX_BIAS_RELATIVE 0.95f
#define PX_BIAS_ABSOLUTE 0.01f

//-------------------------------------------------------------------------------
// Fast Inverse Square Root
//-------------------------------------------------------------------------------

/**
 * @brief Computes the fast inverse square root of a number.
 *
 * This function uses a fast approximation algorithm to compute the inverse
 * square root.
 *
 * @param x - input value
 *
 * @return inverse square root of the input value
 */
static inline float pxFastRsqrt(float x) {
  union {
    float f;
    uint32_t u;
  } f32u32;

  f32u32.f = x;

  f32u32.u =
      0x5f3759df - (f32u32.u >> 1); // Magic number for fast inverse square root

  f32u32.f *= 1.5f - (x * 0.5f * f32u32.f * f32u32.f);

  return f32u32.f;
}

/**
 * @brief Computes the fast reciprocal of a number.
 *
 * This function uses the fast inverse square root to compute the reciprocal.
 *
 * @param x - input value
 *
 * @return reciprocal of the input value
 */
static inline float pxFastRcp(float x) {
  x = pxFastRsqrt(x);
  return x * x;
}

/**
 * @brief Computes the fast safe reciprocal of a number.
 *
 * This function returns 0 if the input is 0 to avoid division by zero.
 *
 * @param x - input value
 *
 * @return The safe reciprocal of the input value
 */
static inline float pxFastSafeRcp(float x) { return x ? pxFastRcp(x) : 0; }

/**
 * @brief Computes the fast division of two numbers.
 *
 * This function uses the fast reciprocal to compute the division.
 *
 * @param numerator
 * @param denominator
 *
 * @return result of the division.
 */
static inline float pxFastDiv(float numerator, float denominator) {
  return numerator * pxFastRcp(denominator);
}

/**
 * @brief Computes the fast square root of a number.
 *
 * This function uses the fast inverse square root to compute the square root.
 *
 * @param x - input value
 *
 * @return square root of the input value
 */
static inline float pxFastSqrt(float x) { return x * pxFastRsqrt(x); }

//-------------------------------------------------------------------------------
// Rounding
//-------------------------------------------------------------------------------

/**
 * @brief Clamps a value between a minimum and maximum.
 *
 * @param x   - input value
 * @param min - minimum value
 * @param max - maximum value
 *
 * @return clamped value
 */
static inline float pxClamp(float x, float min, float max) {
  if (x < min) {
    return min;
  }

  if (x > max) {
    return max;
  }

  return x;
}

/**
 * @brief Converts a float to an integer with rounding.
 *
 * @param x - input value
 *
 * @return rounded integer value
 */
static inline int32_t pxToInt(float x) { return (int32_t)(x + 0.5f); }

//-------------------------------------------------------------------------------
// Comparison
//-------------------------------------------------------------------------------

/**
 * @brief Compares two values with a bias.
 *
 * This function checks if `a` is greater than or equal to `b` with a relative
 * and absolute bias.
 *
 * @param a - first value
 * @param b - second value
 *
 * @return true if `a` is greater than or equal to `b` with bias, false
 *         otherwise
 */
static inline bool pxBiasGt(float a, float b) {
  return a >= b * PX_BIAS_RELATIVE + a * PX_BIAS_ABSOLUTE;
}

/**
 * @brief Returns the minimum of two values.
 *
 * @param a - first value
 * @param b - second value
 *
 * @return minimum value
 */
static inline float pxMin(float a, float b) { return a < b ? a : b; }

//-------------------------------------------------------------------------------
// Random
//-------------------------------------------------------------------------------

/**
 * @brief Generates a random float between a specified range.
 *
 * @param low  - lower bound of the range
 * @param high - upper bound of the range
 *
 * @return random float between `low` and `high`
 */
static inline float pxRandf(float low, float high) {
  return low + (high - low) * pxFastDiv(rand(), (float)RAND_MAX);
}


/**
 * @file vec2.h
 *
 * @brief This file contains functions for handling 2D vector operations.
 *
 * The functions provided in this file are used to create, manipulate, and use
 * 2D vectors. These operations include addition, subtraction, multiplication,
 * division, dot product, cross product, length calculation, normalization, and
 * more.
 */




#define PX_VEC2_ARRAY_MAX_SIZE 32

/**
 * @brief Definition of a 2D vector structure with multiple access methods.
 */
typedef struct {
  union {
    float v[2];
    struct {
      float x, y;
    };
  };
} PxVec2;

/**
 * @brief Creates a 2D vector from x and y components.
 *
 * @param x
 * @param y
 *
 * @return 2D vector
 */
static inline PxVec2 pxVec2(float x, float y) {
  return (PxVec2){.x = x, .y = y};
}

/**
 * @brief Sets the x and y components of an existing 2D vector.
 *
 * @param vector
 * @param x
 * @param y
 *
 * @return The updated vector
 */
static inline PxVec2 *pxVec2Set(PxVec2 *vector, float x, float y) {
  vector->x = x;
  vector->y = y;

  return vector;
}

//-------------------------------------------------------------------------------
// Negation
//-------------------------------------------------------------------------------

/**
 * @brief Negates a 2D vector.
 *
 * @param vector
 *
 * @return negated vector
 */
static inline PxVec2 pxVec2Neg(const PxVec2 vector) {
  return (PxVec2){.x = -vector.x, .y = -vector.y};
}

/**
 * @brief Negates a 2D vector in place.
 *
 * @param vector
 *
 * @return updated vector
 */
static inline PxVec2 *pxVec2NegAssign(PxVec2 *vector) {
  vector->x = -vector->x;
  vector->y = -vector->y;

  return vector;
}

//-------------------------------------------------------------------------------
// Addition
//-------------------------------------------------------------------------------

/**
 * @brief Adds a scalar to a 2D vector.
 *
 * @param vector
 * @param scalar
 *
 * @return resulting vector
 */
static inline PxVec2 pxVec2Addf(const PxVec2 vector, float scalar) {
  return (PxVec2){.x = vector.x + scalar, .y = vector.y + scalar};
}

/**
 * @brief Adds a scalar to a 2D vector in place.
 *
 * @param vector
 * @param scalar
 *
 * @return The updated vector
 */
static inline PxVec2 *pxVec2AddfAssign(PxVec2 *vector, float scalar) {
  vector->x += scalar;
  vector->y += scalar;

  return vector;
}

/**
 * @brief Adds two 2D vectors.
 *
 * @param vector1
 * @param vector2
 *
 * @return The resulting vector
 */
static inline PxVec2 pxVec2Add(const PxVec2 vector1, const PxVec2 vector2) {
  return (PxVec2){.x = vector1.x + vector2.x, .y = vector1.y + vector2.y};
}

/**
 * @brief Adds a 2D vector to another 2D vector in place.
 *
 * @param vector  - vector to be updated
 * @param vector2 - vector to add
 *
 * @return updated vector
 */
static inline PxVec2 *pxVec2AddAssign(PxVec2 *vector, const PxVec2 vector2) {
  vector->x += vector2.x;
  vector->y += vector2.y;

  return vector;
}

//-------------------------------------------------------------------------------
// Subtraction
//-------------------------------------------------------------------------------

/**
 * @brief Subtracts a scalar from a 2D vector.
 *
 * @param vector
 * @param scalar
 *
 * @return resulting vector
 */
static inline PxVec2 pxVec2Subf(const PxVec2 vector, float scalar) {
  return (PxVec2){.x = vector.x - scalar, .y = vector.y - scalar};
}

/**
 * @brief Subtracts a scalar from a 2D vector in place.
 *
 * @param vector
 * @param scalar
 *
 * @return updated vector
 */
static inline PxVec2 *pxVec2SubfAssign(PxVec2 *vector, float scalar) {
  vector->x -= scalar;
  vector->y -= scalar;

  return vector;
}

/**
 * @brief Subtracts one 2D vector from another.
 *
 * @param vector1
 * @param vector2
 *
 * @return resulting vector
 */
static inline PxVec2 pxVec2Sub(const PxVec2 vector1, const PxVec2 vector2) {
  return (PxVec2){.x = vector1.x - vector2.x, .y = vector1.y - vector2.y};
}

/**
 * @brief Subtracts a 2D vector from another 2D vector in place.
 *
 * @param vector  - vector to be updated
 * @param vector2 - vector to subtract
 *
 * @return updated vector
 */
static inline PxVec2 *pxVec2SubAssign(PxVec2 *vector, const PxVec2 vector2) {
  vector->x -= vector2.x;
  vector->y -= vector2.y;

  return vector;
}

//-------------------------------------------------------------------------------
// Multiplication
//-------------------------------------------------------------------------------

/**
 * @brief Multiplies a 2D vector by a scalar.
 *
 * @param vector
 * @param scalar
 *
 * @return resulting vector
 */
static inline PxVec2 pxVec2Multf(const PxVec2 vector, float scalar) {
  return (PxVec2){.x = vector.x * scalar, .y = vector.y * scalar};
}

/**
 * @brief Multiplies a 2D vector by a scalar in place.
 *
 * @param vector - vector to be updated
 * @param scalar
 *
 * @return updated vector
 */
static inline PxVec2 *pxVec2MultfAssign(PxVec2 *vector, float scalar) {
  vector->x *= scalar;
  vector->y *= scalar;

  return vector;
}

/**
 * @brief Multiplies two 2D vectors component-wise.
 *
 * @param vector1
 * @param vector2
 *
 * @return resulting vector
 */
static inline PxVec2 pxVec2Mult(const PxVec2 vector1, const PxVec2 vector2) {
  return (PxVec2){.x = vector1.x * vector2.x, .y = vector1.y * vector2.y};
}

/**
 * @brief Multiplies a 2D vector by another 2D vector component-wise in place.
 *
 * @param vector  - vector to be updated.
 * @param vector2 - vector to multiply with.
 *
 * @return updated vector
 */
static inline PxVec2 *pxVec2MultAssign(PxVec2 *vector, const PxVec2 vector2) {
  vector->x *= vector2.x;
  vector->y *= vector2.y;

  return vector;
}

//-------------------------------------------------------------------------------
// Division
//-------------------------------------------------------------------------------

/**
 * @brief Divides a 2D vector by a scalar.
 *
 * @param vector
 * @param scalar
 *
 * @return resulting vector
 */
static inline PxVec2 pxVec2Divf(const PxVec2 vector, float scalar) {
  return (PxVec2){.x = pxFastDiv(vector.x, scalar),
                  .y = pxFastDiv(vector.y, scalar)};
}

/**
 * @brief Divides a 2D vector by a scalar in place.
 *
 * @param vector - vector to be updated
 * @param scalar
 *
 * @return updated vector
 */
static inline PxVec2 *pxVec2DivfAssign(PxVec2 *vector, float scalar) {
  vector->x = pxFastDiv(vector->x, scalar);
  vector->y = pxFastDiv(vector->y, scalar);

  return vector;
}

/**
 * @brief Divides one 2D vector by another component-wise.
 *
 * @param vector1
 * @param vector2
 *
 * @return resulting vector
 */
static inline PxVec2 pxVec2Div(const PxVec2 vector1, const PxVec2 vector2) {
  return (PxVec2){.x = pxFastDiv(vector1.x, vector2.x),
                  .y = pxFastDiv(vector1.y, vector2.y)};
}

/**
 * @brief Divides a 2D vector by another 2D vector component-wise in place.
 *
 * @param vector  - vector to be updated
 * @param vector2 - vector to divide by
 *
 * @return updated vector
 */
static inline PxVec2 *pxVec2DivAssign(PxVec2 *vector, const PxVec2 vector2) {
  vector->x = pxFastDiv(vector->x, vector2.x);
  vector->y = pxFastDiv(vector->y, vector2.y);

  return vector;
}

//-------------------------------------------------------------------------------
// Cross Product
//-------------------------------------------------------------------------------

/**
 * @brief Computes the cross product of a 2D vector and a scalar.
 *
 * @param vector
 * @param scalar
 *
 * @return resulting vector
 */
static inline PxVec2 pxVec2Crossf(const PxVec2 vector, float scalar) {
  return (PxVec2){.x = vector.y * scalar, .y = -vector.x * scalar};
}

/**
 * @brief Computes the cross product of two 2D vectors.
 *
 * @param vector1
 * @param vector2
 *
 * @return resulting scalar
 */
static inline float pxVec2Cross(const PxVec2 vector1, const PxVec2 vector2) {
  return vector1.x * vector2.y - vector1.y * vector2.x;
}

//-------------------------------------------------------------------------------
// Dot Product
//-------------------------------------------------------------------------------

/**
 * @brief Computes the dot product of two 2D vectors.
 *
 * @param vector1
 * @param vector2
 *
 * @return resulting scalar
 */
static inline float pxVec2Dot(const PxVec2 vector1, const PxVec2 vector2) {
  return vector1.x * vector2.x + vector1.y * vector2.y;
}

//-------------------------------------------------------------------------------
// Length
//-------------------------------------------------------------------------------

/**
 * @brief Computes the squared length of a 2D vector.
 *
 * @param vector
 *
 * @return squared length
 */
static inline float pxVec2LenSqr(const PxVec2 vector) {
  return vector.x * vector.x + vector.y * vector.y;
}

/**
 * @brief Computes the length of a 2D vector.
 *
 * @param vector
 *
 * @return length
 */
static inline float pxVec2Len(const PxVec2 vector) {
  return pxFastSqrt(pxVec2LenSqr(vector));
}

//-------------------------------------------------------------------------------
// Tangent
//-------------------------------------------------------------------------------

/**
 * @brief Computes the tangent of a 2D vector with respect to a normal vector.
 *
 * @param vector
 * @param normal - normal vector
 *
 * @return resulting tangent vector
 */
static inline PxVec2 pxVec2Tangent(const PxVec2 vector, const PxVec2 normal) {
  float projection = pxVec2Dot(vector, normal);
  return pxVec2Sub(vector, pxVec2Multf(normal, projection));
}

//-------------------------------------------------------------------------------
// Distance
//-------------------------------------------------------------------------------

/**
 * @brief Computes the squared distance between two 2D vectors.
 *
 * @param vector1
 * @param vector2
 *
 * @return squared distance
 */
static inline float pxVec2DistSqr(const PxVec2 vector1, const PxVec2 vector2) {
  PxVec2 d = pxVec2Sub(vector1, vector2);
  return pxVec2Dot(d, d);
}

//-------------------------------------------------------------------------------
// Transform
//-------------------------------------------------------------------------------

/**
 * @brief Rotates a 2D vector by a given angle in radians.
 *
 * @param vector
 * @param radians - angle in radians
 *
 * @return rotated vector
 */
static inline PxVec2 *pxVec2Rotate(PxVec2 *vector, float radians) {
  float c = cosf(radians);
  float s = sinf(radians);

  float originalX = vector->x;
  vector->x = vector->x * c - vector->y * s;
  vector->y = originalX * s + vector->y * c;

  return vector;
}

/**
 * @brief Normalizes a 2D vector.
 *
 * @param vector
 *
 * @return normalized vector
 */
static inline PxVec2 *pxVec2Normalize(PxVec2 *vector) {
  float len = pxVec2Len(*vector);

  if (len <= PX_EPSILON) {
    return vector;
  }

  float invLen = pxFastRcp(len);

  vector->x *= invLen;
  vector->y *= invLen;

  return vector;
}

//===============================================================================
// Array
//===============================================================================

/**
 * @brief Definition of a fixed-size array of 2D vectors with a length.
 */
typedef struct {
  PxVec2 items[2];
  uint8_t length;
} PxVec2Array2;

/**
 * @brief Definition of a variable-size array of 2D vectors with a length.
 */
typedef struct {
  PxVec2 items[PX_VEC2_ARRAY_MAX_SIZE];
  uint8_t length;
} PxVec2Array;

/**
 * @brief Gets a 2D vector from an array at a specified index.
 *
 * @param array
 * @param index
 *
 * @return vector at the specified index, or a zero vector if the index is out
 *         of bounds.
 */
static inline PxVec2 pxVec2ArrayGet(PxVec2Array array, uint8_t index) {
  if (index >= array.length) {
    return pxVec2(0.0f, 0.0f);
  }

  return array.items[index];
}

/**
 * @brief Sets a 2D vector in an array at a specified index.
 *
 * @param array
 * @param index
 * @param value
 */
static inline void pxVec2ArraySet(PxVec2Array *array, uint8_t index,
                                  PxVec2 value) {
  if (index >= array->length) {
    return;
  }

  array->items[index] = value;
}


/**
 * @file collider.h
 *
 * @brief Defines the interface for collider objects in the pdphyzx engine.
 *
 * This header file provides the necessary functions and structures to create
 * and manage different types of colliders, including their shapes and
 * properties.
 *
 * It includes definitions for creating new colliders, handling shape data, and
 * specifying collider types.
 *
 * The functions and structures in this file are essential for the collision
 * detection and response system within the pdphyzx engine.
 */




/**
 * @brief Defines the type of physical collider
 */
typedef enum {
  PX_CIRCLE, /**< Circular collider */
  PX_POLYGON /**< Polygon-shaped collider */
} PxColliderType;

/**
 * @brief Data structure for circular colliders
 */
typedef struct PxCircleData {
  float radius; /**< Radius of the circle */
} PxCircleData;

/**
 * @brief Maximum number of vertices allowed in a polygon collider
 * @note Derived from VEC2_ARRAY_MAX_SIZE which defines maximum vector array
 *       size
 */
#define PX_MAX_POLY_VERTEX_COUNT PX_VEC2_ARRAY_MAX_SIZE

typedef struct PxPolygonData {
  PxVec2Array vertices;
  PxVec2Array normals;
  float maxRadius; /**< Maximum distance from center to any vertex */
} PxPolygonData;

/**
 * @brief Union containing data for different collider types
 */
typedef union {
  PxCircleData circle;   /**< Data for circular colliders */
  PxPolygonData polygon; /**< Data for polygon colliders */
} PxShapeData;

// Forward declaration
typedef struct PxCollider PxCollider;

typedef void (*PxColliderDestroyImpl)(PxCollider *c);

/**
 * @brief Physical mass properties for a collider
 */
typedef struct {
  float mass;  /**< Mass of the collider */
  float iMass; /**< Inverse mass (1/mass) for efficient calculations */
  float momentOfInertia;  /**< Moment of inertia around the center of mass */
  float iMomentOfInertia; /**< Inverse moment of inertia for calculations */
} PxMassData;

typedef PxMassData (*PxColliderComputeMassImpl)(PxCollider *collider,
                                                float density);
typedef struct {
  PxVec2 min;
  PxVec2 max;
} PxAABB;

typedef void (*PxColliderUpdateAABB)(PxCollider *collider, PxAABB *outAABB,
                                     PxVec2 position);

typedef struct PxCollider {
  PxShapeData shape;
  PxColliderType type;
  PxColliderComputeMassImpl computeMass;
  PxColliderUpdateAABB updateAABB;
  PxColliderDestroyImpl destroy;
} PxCollider;

/**
 * Creates a new collider with the specified type and shape data
 *
 * @param type  - type of collider (circle, box, etc.) from PxColliderType enum
 * @param shape - union containing shape-specific data based on the collider
 *                type
 *
 * @return A new PxCollider instance with the specified properties
 *
 * @note This is a low-level function. Consider using shape-specific creation
 *       functions like pxCreateCircleCollider instead of calling this
 *       directly.
 *
 * @see pxCreateCircleCollider, pxCreateBoxCollider
 */
PxCollider pxColliderNew(PxColliderType type, PxShapeData shape);


/**
 * @file polygon.h
 *
 * @brief Defines functions and structures for polygon-based colliders in the
 *        pdphyzx engine.
 *
 * This header provides the interface for creating and manipulating polygon
 * colliders, including functions for creating new polygon and box colliders,
 * processing polygon data, and computing mass properties for polygon colliders.
 *
 * The functions in this file are designed to work with the pdphyzx engine's
 * collider system, allowing for the creation of complex polygon shapes and the
 * calculation of their physical properties.
 */




/**
 * Creates a new polygon collider from the given vertices.
 *
 * @param vertices - array of vertex positions defining the polygon outline
 * @param count    - number of vertices in the array
 *
 * @return A new PxCollider initialized as a polygon shape
 */
PxCollider pxPolygonColliderNew(PxVec2 vertices[], uint8_t count);

/**
 * Creates a new box collider centered at the origin.
 *
 * @param width  - width of the box along x-axis
 * @param height - height of the box along y-axis
 *
 * @return A new PxCollider initialized as a rectangular shape
 */
PxCollider pxBoxColliderNew(float width, float height);

/**
 * @brief Finds the support point of a polygon in a given direction
 *
 * The support point is the vertex with the maximum projection along the
 * specified direction. This function is commonly used in collision detection
 * algorithms such as SAT (Separating Axis Theorem) and GJK.
 *
 * @param polygon   - polygon data containing vertices to search
 * @param direction - direction vector to project vertices onto
 *
 * @return The vertex with the maximum projection in the given direction.
 *         If direction is (near) zero, returns a zero vector.
 *
 * @note Time complexity: O(n) where n is the number of vertices in the polygon
 */
PxVec2 pxPolygonGetSupport(const PxPolygonData polygon, const PxVec2 direction);


/**
 * @file circle.h
 *
 * @brief Circle collider implementation for the pdphyzx engine
 *
 * This header provides functions for creating and working with circular
 * colliders in 2D physics simulations.
 */



/**
 * Creates a new circular collider with the specified radius.
 *
 * @param radius - radius of the circle (must be positive)
 *
 * @return A new PxCollider instance configured as a circle
 *
 * @note Returns an invalid collider if radius <= 0
 */
extern PxCollider pxCircleColliderNew(float radius);

extern PxMassData pxCircleComputeMass(PxCollider *collider, float density);


/**
 * @file mat2.h
 * @brief This file contains functions for handling 2x2 matrix operations.
 *
 * The functions provided in this file are used to create, manipulate, and use
 * 2x2 matrices. These operations include creating rotation matrices, setting
 * matrix orientation, transposing matrices, and multiplying matrices by 2D
 * vectors.
 */



/**
 * @brief Definition of a 2x2 matrix structure with multiple access methods.
 */
typedef struct {
  union {
    struct {
      float m00, m01;
      float m10, m11;
    };
    float m[2][2];
    float v[4];
  };
} PxMat2;

/**
 * @brief Creates a 2x2 identity matrix.
 *
 * `[ 1 0 ]`
 * `[ 0 1 ]`
 *
 * @return 2x2 identity matrix.
 */
static inline PxMat2 pxMat2Identity(void) {
  return (PxMat2){.m00 = 1, .m01 = 0, .m10 = 0, .m11 = 1};
}

/**
 * @brief Creates a 2x2 rotation matrix from an angle in radians.
 *
 * `[ cos(r) -sin(r) ]`
 * `[ sin(r)  cos(r) ]`
 *
 * @param radians - angle in radians.
 *
 * @return 2x2 rotation matrix.
 */
static inline PxMat2 pxMat2Orientation(float radians) {
  float c = cosf(radians);
  float s = sinf(radians);

  return (PxMat2){.m00 = c, .m01 = -s, .m10 = s, .m11 = c};
}

/**
 * @brief Sets the orientation of an existing 2x2 matrix to a rotation defined
 * by an angle in radians.
 *
 * @param mat2    - pointer to the 2x2 matrix.
 * @param radians - angle in radians.
 */
static inline void mat2SetOrientation(PxMat2 *mat2, float radians) {
  float c = cosf(radians);
  float s = sinf(radians);

  mat2->m00 = c;
  mat2->m01 = -s;
  mat2->m10 = s;
  mat2->m11 = c;
}

/**
 * @brief Transposes a 2x2 matrix.
 *
 * @param mat2 - 2x2 matrix to transpose.
 *
 * @return transposed 2x2 matrix.
 */
static inline PxMat2 pxMat2Transpose(PxMat2 mat2) {
  return (PxMat2){
      .m00 = mat2.m00,
      .m01 = mat2.m10,
      .m10 = mat2.m01,
      .m11 = mat2.m11,
  };
}

/**
 * @brief Multiplies a 2x2 matrix by a 2D vector.
 *
 * @param mat2 - 2x2 matrix.
 * @param v    - 2D vector.
 *
 * @return resulting 2D vector.
 */
static inline PxVec2 pxMat2MultVec2(PxMat2 mat2, PxVec2 v) {
  return pxVec2(mat2.m00 * v.x + mat2.m01 * v.y,
                mat2.m10 * v.x + mat2.m11 * v.y);
}





/**
 * @brief Maximum number of bodies that can exist in the simulation
 */
#define PX_MAX_BODIES 64

/**
 * @brief Special value indicating a body is not assigned to any world
 */
#define PX_INVALID_WORLD_INDEX 255

#define PX_BODY_WAKE_THRESHOLD 0.0001f

/**
 * @brief Represents a circular shape in the physics system
 */
typedef struct {
  float radius; /**< Radius of the circle */
} PxCircle;

/**
 * @brief Represents a polygon shape in the physics system
 */
typedef struct {
  PxVec2 vertices[PX_MAX_POLY_VERTEX_COUNT]; /**< Array of vertices defining the
                                           polygon */

  size_t vertexCount; /**< Number of vertices in use
                           (must be <=PX_MAX_POLY_VERTEX_COUNT) */
} PxPolygon;

/**
 * @brief Represents a box shape in the physics system
 */
typedef struct {
  float width;  /**< Width of the box */
  float height; /**< Height of the box */
} PxBox;

/**
 * @brief Container for shape data to simplify body creation API
 *
 * @note Initialize only ONE of these fields when creating a shape.
 * - Example for circle: (PxShape){ .circle = { .radius = 1.0f } }
 * - Example for box: (PxShape){ .box = { .width = 2.0f, .height = 1.0f } }
 */
typedef struct {
  PxCircle
      circle; /**< Circle shape data (initialize this for circular bodies) */
  PxPolygon
      polygon; /**< Polygon shape data (initialize this for polygon bodies) */
  PxBox box;   /**< Box shape data (initialize this for box bodies) */
} PxShape;

/**
 * @brief Represents a physical body in the simulation
 */
typedef struct {
  // Group by simulation step access patterns (hot data first)
  PxVec2 position;        /**< Current position */
  PxVec2 velocity;        /**< Linear velocity */
  PxMat2 orientation;     /**< Rotation matrix for the body */
  PxVec2 force;           /**< Accumulated force for current step */
  float angularVelocity;  /**< Rotational velocity in radians/sec */
  float torque;           /**< Accumulated torque for current step */
  float orientationAngle; /**< Orientation angle in radians */

  // Mass properties (accessed together in force calculations)
  float mass;  /**< Mass of the body */
  float iMass; /**< Inverse mass (1/mass) for efficient calculations */
  float momentOfInertia;  /**< Moment of inertia for rotation */
  float iMomentOfInertia; /**< Inverse moment of inertia for calculations */

  // Material properties (accessed together in collision response)
  float restitution;     /**< Bounciness coefficient (0-1) */
  float staticFriction;  /**< Friction coefficient when stationary */
  float dynamicFriction; /**< Friction coefficient when moving */
  float density;         /**< Material density for mass calculations */

  // Collision related data
  PxAABB aabb; /** < Axis-aligned bounding box for broad-phase collision */
  PxCollider collider; /**< Collision shape of the body */

  // Small fields at the end to maintain alignment
  uint8_t worldIndex; /**< Index in body array of world containing this body or
                           INVALID_WORLD_INDEX */

  bool isValid;    /**< Flag indicating if the body is valid */
  uint8_t padding; /**< Padding to maintain 4-byte alignment */
  float sleepTime; /**< Time the body has been below motion threshold */
} PxBody;

void pxBodySetPosition(PxBody *body, PxVec2 position);

void pxBodyMoveBy(PxBody *body, PxVec2 distance);

/**-
 * @brief Creates a new physics body
 *
 * @param shape    - collision shape of the body (initialize only one field)
 * @param density  - material density used for mass calculations
 * @param position - initial position of the body
 *
 * @return A new PxBody instance
 *
 * @example
 * // Create a circular body
 * PxBody circle = pxBodyNew(
 *   (PxShape){ .circle = { .radius = 1.0f } }, 1.0f, vec2(0, 0)
 * );
 *
 * // Create a box body
 * PxBody box = pxBodyNew(
 *   (PxShape){ .box = { .width = 2.0f, .height = 1.0f } }, 1.0f, vec2(0, 0)
 * );
 *
 * @note Returns by value for simplicity and to avoid memory management
 *       concerns; check the isValid field to confirm successful creation
 */
PxBody pxBodyNew(PxShape shape, float density, PxVec2 position);

/**
 * @brief Updates a body's rotation to a desired angle
 *
 * @param body    - pointer to the body to update (if NULL, function is a no-op)
 * @param radians - orientation angle in radians
 */
void pxBodySetOrientation(PxBody *body, float radians);

/**
 * @brief Rotates a body by a specified angle
 *
 * @param body    - pointer to the body to rotate (if NULL, function is a no-op)
 * @param radians - angle to rotate the body by in radians
 */
void pxBodyRotate(PxBody *body, float radians);

// TODO: Flesh these out + add comments
void pxBodyApplyForce(PxBody *body, PxVec2 force, PxVec2 contact);
void pxBodyApplyImpulse(PxBody *body, PxVec2 impulse, PxVec2 contact);

/**
 * @brief Updates the Axis-Aligned Bounding Box (AABB) for a physics body
 *
 * This function updates the body's AABB by calling the collider's updateAABB
 * method. For both circles and polygons, a radius-based approach is used where
 * the AABB is calculated as position ± radius. This provides a fast,
 * conservative bound for broad-phase collision detection.
 *
 * @param body - physics body whose AABB needs to be updated
 *
 * @note For efficiency, this uses a circular approximation for all collider
 *       shapes
 */
void pxBodyUpdateAABB(PxBody *body);

/**
 * @brief Determines whether two AABBs overlap
 *
 * Two AABBs overlap when they intersect on both the x and y axes.
 * This is a fast broad-phase collision check.
 *
 * @param bodyA
 * @param bodyB
 * @return true if the AABBs overlap, false otherwise
 */
bool pxBodyAABBsOverlap(PxBody *bodyA, PxBody *bodyB);

/**
 * @brief Integrates forces acting on a body over a time step
 *
 * This function updates the body's velocity based on the accumulated forces
 * and the provided gravitational acceleration.
 *
 * @param body - pointer to the body to integrate (if NULL, function is a
 * no-op)
 * @param g    - gravitational acceleration vector
 * @param dt   - time step duration
 */
void pxBodyIntegrateForces(PxBody *body, PxVec2 g, float dt);

/**
 * @brief Integrates the body's velocity over a time step
 *
 * This function updates the body's position based on its current velocity
 * and the provided time step duration.
 *
 * @param body - pointer to the body to integrate (if NULL, function is a
 * no-op)
 * @param dt   - time step duration
 */
void pxBodyIntegrateVelocity(PxBody *body, float dt);

/**
 * @brief Clears all accumulated forces acting on the body
 *
 * This function resets the forces acting on the specified body to zero,
 * effectively removing any applied forces.
 *
 * @param body Pointer to the body whose forces are to be cleared
 */
void pxBodyClearForces(PxBody *body);

void pxBodyWakeUp(PxBody *body);

/**
 * @brief Array container for efficiently managing body instances
 *
 * Uses separate active/freed index arrays to allow fast iteration over only
 * active bodies while maintaining O(1) addition and removal.
 */
typedef struct {
  PxBody items[PX_MAX_BODIES]; /**< Storage for body data */

  // Small metadata arrays for efficient body management
  uint8_t length;     /**< Number of active bodies */
  uint8_t freedCount; /**< Number of freed slots available for reuse */

  uint16_t padding; // Align to 4 bytes

  // These small arrays have good cache locality
  uint8_t activeIndices[PX_MAX_BODIES]; /**< Indices of active bodies for fast
                                        iteration */
  uint8_t freedIndices[PX_MAX_BODIES]; /**< Indices of freed slots available for
                                       reuse */
} PxBodyArray;

/**
 * @brief Macro for iterating through active bodies
 *
 * Usage:
 *
 * ```
 * pxBodyArrayEach(bodyArray, body) { // Start from beginning
 *    // body is a pointer to the current active body
 *    pxBodyApplyForce(body, ...);
 *  }
 * ```
 */
#define pxBodyArrayEach(array, body)                                           \
  for (uint8_t _i = 0; _i < (array)->length; _i++)                             \
    for (PxBody *body = &(array)->items[(array)->activeIndices[_i]]; body;     \
         body = NULL)

/**
 * @brief Macro for iterating through active bodies starting from an index
 *
 * Usage:
 *
 * ```
 * pxBodyArrayEachFrom(bodyArray, 5, body) { // Start from 5th
 *    // body is a pointer to the current active body
 *    pxBodyApplyForce(body, ...);
 *  }
 * ```
 */
#define pxBodyArrayEachFrom(array, offset, body)                               \
  for (uint8_t _i = (offset); _i < (array)->length; ++_i)                      \
    for (PxBody *body = &(array)->items[(array)->activeIndices[_i]]; body;     \
         body = NULL)

/**
 * @brief Macro for iterating through active bodies while tracking current index
 *
 * Usage:
 *
 * ```
 * pxBodyArrayEachFrom(bodyArray, body, idx) {
 *    printf("Current index: %d\n", idx);
 *
 *    // body is a pointer to the current active body
 *    pxBodyApplyForce(body, ...);
 *  }
 * ```
 */
#define pxBodyArrayEachWithIdx(array, body, idx)                               \
  for (uint8_t idx = 0; idx < (array)->length; idx++)                          \
    for (PxBody *body = &(array)->items[(array)->activeIndices[idx]]; body;    \
         body = NULL)

/**
 * @brief Adds a body to the array
 *
 * @param array - pointer to the body array
 * @param body  - pointer to the body to add
 *
 * @return Pointer to the stored body or NULL if array is full or body is
 *         invalid
 */
PxBody *pxBodyArrayAdd(PxBodyArray *array, PxBody *body);

/**
 * @brief Removes a body from the array
 *
 * @param array - pointer to the body array
 * @param index - index of the body to remove
 *
 * @note Attempting to remove an invalid index or already removed body is a
 *       no-op
 */
void pxBodyArrayRemove(PxBodyArray *array, uint8_t index);

/**
 * @brief Sorts the bodies in the array by their minimum X axis coordinate.
 *
 * This function reorders only the internal activeIndices array to optimize
 * broad-phase collision detection using a sweep-and-prune algorithm. The
 * bodies themselves remain in their original memory locations, so external
 * pointers to bodies remain valid after sorting.
 *
 * @param bodies - pointer to the body array to be sorted
 *
 * @note This is typically used before collision detection to reduce the
 * number of detailed collision checks required
 */
void pxBodyArraySortByAxis(PxBodyArray *bodies);

/**
 * @brief Finds the index of the first body in a sorted array that could
 * potentially overlap with a body having the given minimum x-coordinate
 *
 * Uses binary search on a PxBodyArray that has been sorted by min.x
 *
 * @param bodies - bodies sorted by min.x coordinate
 * @param minX   - minimum x-coordinate to test against
 *
 * @return index of the first potential overlapping body
 */
uint8_t pxBodyArrayFindFirstIndexAfterX(PxBodyArray *bodies, float minX);





/**
 * Maximum number of contact points stored in a manifold.
 * For 2D physics, two points is typically sufficient.
 */
#define PX_MAX_CONTACTS 2

// Maximum penetration allowed before position correction
#define PX_ALLOWED_PENETRATION 0.01f

// Baumgarte stabilization factor (0.2-0.8) controlling correction strength
#define PX_POSITIONAL_CORRECTION_FACTOR 0.2f

/**
 * @brief Contact manifold between two colliding bodies.
 *
 * A manifold stores information about a collision between two bodies, including
 * the collision normal, penetration depth, contact points, and material
 * properties needed for collision resolution.
 */
typedef struct PxManifold {
  // Start with 4-byte pointer fields
  PxBody *bodyA; /**< First body involved in collision */
  PxBody *bodyB; /**< Second body involved in collision */

  // Vec2 (8 bytes, naturally aligned to 4 bytes on ARM)
  PxVec2 normal; /**< Contact normal vector (points from bodyA to bodyB) */

  // Group all floats together (4 bytes each)
  float penetration;      /**< Penetration depth between bodies */
  float staticFriction;   /**< Combined static friction */
  float dynamicFriction;  /**< Combined dynamic friction */
  float mixedRestitution; /**< Combined coefficient of restitution (bounce) */

  // Place Vec2Array last (contains two Vec2 and a uint8_t length)
  PxVec2Array2 contacts; /**< Array of contact points between bodies */
} PxManifold;

/**
 * @brief Initialize an existing manifold.
 *
 * @param manifold - manifold to initialize
 * @param bodyA    - first body in the collision pair
 * @param bodyB    - second body in the collision pair
 *
 * @return Initialized manifold (same as input)
 */
PxManifold *pxManifoldInit(PxManifold *manifold, PxBody *bodyA, PxBody *bodyB);

/**
 * @brief Detect collision between the bodies in the manifold.
 *
 * Populates the manifold with contact information if a collision is detected.
 * After calling, check if manifold->contacts.length > 0 to confirm collision.
 *
 * @param manifold - manifold to solve (modified in-place)
 */
void pxManifoldSolve(PxManifold *manifold);

/**
 * @brief Determine if the contacts represent a resting collision.
 *
 * Resting contacts occur when objects are stacked or sitting on each other.
 * This function adjusts restitution to prevent objects from bouncing when
 * their relative velocity is below what would be caused by gravity in one step.
 *
 * @param manifold - manifold to analyze (modified in-place)
 * @param gy       - current gravity vector
 * @param dt       - time step in seconds
 */
void pxManifoldDetectRestingContact(PxManifold *manifold, PxVec2 g, float dt);

/**
 * @brief Apply collision impulses to resolve the contact.
 *
 * Calculates and applies impulses to both bodies to resolve velocity
 * constraints based on friction and restitution.
 *
 * @param manifold - manifold containing collision data (bodies modified
 *                   in-place)
 */
void pxManifoldApplyImpulse(PxManifold *manifold);

/**
 * @brief Correct position overlap between colliding bodies.
 *
 * Adjusts body positions to eliminate excessive interpenetration.
 * This helps prevent jittering and improves simulation stability.
 *
 * @param manifold - manifold containing collision data (bodies modified
 *                   in-place)
 */
void pxManifoldCorrectPosition(PxManifold *manifold);


/**
 * @file collision.h
 * @brief This file contains functions for handling collision detection and
 * response.
 *
 * The functions provided in this file are used to detect and handle collisions
 * between different shapes (circles and polygons) and to clip line segments
 * against lines defined by normal vectors and offsets. These functions are
 * essential for collision detection in physics simulations.
 */



/**
 * Detects and handles the collision between two bodies.
 *
 * @param bodyA    - first body involved in the collision.
 * @param bodyB    - second body involved in the collision.
 * @param manifold - manifold to store collision information.
 */
void pxCollide(PxBody *bodyA, PxBody *bodyB, PxManifold *manifold);





#define PX_MAX_MANIFOLDS 64

typedef struct {
  PxManifold items[PX_MAX_MANIFOLDS];
  uint8_t length;
} PxManifoldPool;

/**
 * @brief Macro for iterating through all manifolds in a pool
 *
 * Usage:
 *   pxManifoldPoolEach(pool, manifold) {
 *     // manifold is a pointer to the current manifold
 *   }
 */
#define pxManifoldPoolEach(pool, manifold)                                     \
  for (uint8_t _i = 0; _i < (pool)->length; ++_i)                              \
    for (PxManifold *manifold = &(pool)->items[_i]; manifold; manifold = NULL)

PxManifold *pxManifoldPoolAcquire(PxManifoldPool *pool);
void pxManifoldPoolReleaseLast(PxManifoldPool *pool);
void pxManifoldPoolClear(PxManifoldPool *pool);



typedef struct {
  uint32_t lastUpdateMs;
  float accumulator;
  float fixedTimestep;
  uint8_t targetFps;
  uint8_t maxStepsPerFrame;
  bool isFirstUpdate;
} PxClock;

PxClock *pxClockInit(PxClock *clock, uint8_t targetFps);

void pxClockBeginFrame(PxClock *clock);

bool pxClockShouldStep(PxClock *clock);

float pxClockGetFixedDeltaTime(PxClock *clock);

void pxClockAdvance(PxClock *clock);

void pxClockSetTargetFPS(PxClock *clock, uint8_t targetFps);

/**
 * @file world.h
 * @brief Physics world management for the PDPhyzx 2D physics engine
 *
 * This header defines the public interface for the physics world component,
 * which is the central container for physical simulation in PDPhyzx.
 * It provides functionality for:
 *  - Creating and destroying physics worlds
 *  - Adding static and dynamic bodies to the simulation
 *  - Advancing the physics simulation with collision detection and resolution
 *  - Managing time steps for stable physics simulation
 *
 * The physics world handles collections of bodies, detects collisions between
 * them, and resolves those collisions according to physical principles.
 */



/**
 * @brief Physics world container that manages physical bodies and simulations
 *
 * The PxWorld struct maintains collections of static and dynamic bodies,
 * handles collision detection, and steps the physics simulation forward in
 * time.
 */
typedef struct {
  PxBodyArray staticBodies;
  PxBodyArray dynamicBodies;
  PxManifoldPool contacts;

  uint8_t iterations;
  float scale;

  float linearSleepThresholdSq; // m/s (squared)
  float angularSleepThreshold;  // rad/s
  float timeToSleep;            // seconds

  PxClock clock;
} PxWorld;

/**
 * @brief Creates a new physics world
 *
 * @param iterations - number of constraint solving iterations per step
 * @param targetFps  - target frames per second for simulation stability
 * @param scale      - scale factor for physics world units
 *
 * @return pointer to newly created PxWorld or NULL if allocation fails
 */
PxWorld *pxWorldNew(uint8_t iterations, uint8_t targetFps, float scale);

/**
 * @brief Destroys a physics world and frees associated memory
 *
 * @param world
 */
void pxWorldFree(PxWorld *world);

/**
 * @brief Creates a new static body in the physics world
 *
 * Static bodies do not move in response to collisions but affect dynamic
 * bodies.
 *
 * @param world
 * @param shape    - shape for collision detection
 * @param position - initial position of the body
 *
 * @return pointer to the newly created static body
 */
PxBody *pxWorldNewStaticBody(PxWorld *world, PxShape shape, PxVec2 position);

/**
 * @brief Creates a new dynamic body in the physics world
 *
 * Dynamic bodies move in response to forces and collisions.
 *
 * @param world
 * @param shape    - shape for collision detection
 * @param density  - density used to calculate mass properties
 * @param position - initial position of the body
 *
 * @return pointer to the newly created dynamic body
 */
PxBody *pxWorldNewDynamicBody(PxWorld *world, PxShape shape, float density,
                              PxVec2 position);

/**
 * @brief Removes a body from the physics world
 *
 * This function removes the specified body from either the static or dynamic
 * body array in the physics world. The body must have been previously added
 * to the world using pxWorldNewStaticBody or pxWorldNewDynamicBody.
 *
 * If the body is not found in either array, this function is a no-op.
 *
 * @param world
 * @param body
 */
void pxWorldFreeBody(PxWorld *world, PxBody *body);

/**
 * @brief Advances the physics simulation by one time step
 *
 * Performs collision detection and resolution, integrates forces, and updates
 * positions of all dynamic bodies.
 *
 * @param world
 * @param g     - gravity vector to apply during the step
 *
 * @return true if step was performed, false if no step was needed based on time
 *         since last call
 */
bool pxWorldStep(PxWorld *world, PxVec2 g);

void pxWorldDrawDebug(PxWorld *world);


/**
 * @file api.h
 *
 * @brief Function pointer API for the PDPhyzx world physics system
 *
 * This header defines the function pointer interface that provides access to
 * the world management functionality of the PDPhyzx 2D physics engine.
 *
 * The API allows for creating and managing physics worlds, adding and removing
 * bodies, and advancing the physics simulation.
 */



/**
 * @brief API structure containing function pointers for world operations
 *
 * This structure provides a consistent interface to the physics world
 * functionality, allowing applications to create, manipulate, and simulate
 * physics worlds.
 */
typedef struct {
  PxWorld *(*new)(uint8_t iterations, uint8_t targetFps, float scale);
  void (*free)(PxWorld *world);
  PxBody *(*newStaticBody)(PxWorld *world, PxShape shape, PxVec2 position);
  PxBody *(*newDynamicBody)(PxWorld *world, PxShape shape, float density,
                            PxVec2 position);
  void (*freeBody)(PxWorld *world, PxBody *body);
  bool (*step)(PxWorld *world, PxVec2 g);
  void (*drawDebug)(PxWorld *world);
} PxWorldAPI;

PxWorldAPI *newPxWorldAPI(void);


/**
 * @file api.h
 * @brief Public API for manipulating physics bodies
 *
 * This header provides the interface for modifying properties of physics
 * bodies in the PdPhyzx engine. All interactions with physics bodies
 * should use these functions rather than modifying body data directly.
 *
 * Example usage:
 *   px_body->setOrientation(myBody, 1.57f); // Set to 90 degrees
 */

#ifndef PX_BODY_API_H
#define PX_BODY_API_H


typedef struct {
  void (*setOrientation)(PxBody *body, float radians);
  void (*rotate)(PxBody *body, float radians);
  void (*applyForce)(PxBody *body, PxVec2 force, PxVec2 contact);
  void (*applyImpulse)(PxBody *body, PxVec2 impulse, PxVec2 force);
} PxBodyAPI;

PxBodyAPI *newPxBodyAPI(void);

#endif // PX_BODY_API_H




typedef struct {
  const PxBodyAPI *body;
  const PxWorldAPI *world;
} PdPhyzxAPI;

PdPhyzxAPI *registerPdPhyzx(PlaydateAPI *playdate);




extern PlaydateAPI *pd;

#ifndef pxalloc
#define pxalloc(x) pd->system->realloc(NULL, (x))
#endif

#ifndef pxfree
#define pxfree(a) pd->system->realloc((a), 0)
#endif

#ifndef pxcalloc
#define pxcalloc(a, b) pd->system->realloc(NULL, ((a) * (b)))
#endif

#ifndef pxrealloc
#define pxrealloc pd->system->realloc
#endif

#ifndef pxlog
#define pxlog(s, ...) pd->system->logToConsole((s), ##__VA_ARGS__)
#endif



#ifdef PDPHYZX_IMPLEMENTATION

// Implementation from src/manifold.c



//==============================================================================
// Allocation
//==============================================================================

PxManifold *pxManifoldInit(PxManifold *manifold, PxBody *bodyA, PxBody *bodyB) {
  // Allocate space for up to 2 contact points (typical for 2D collision)
  manifold->contacts = (PxVec2Array2){0};
  manifold->normal = pxVec2(0, 0);
  manifold->penetration = 0;
  manifold->mixedRestitution = 0;

  manifold->bodyA = bodyA;
  manifold->bodyB = bodyB;

  // Use geometric mean to combine friction coefficients
  // This produces a balanced value between the two materials
  manifold->staticFriction =
      pxFastSqrt(bodyA->staticFriction * bodyB->staticFriction);

  manifold->dynamicFriction =
      pxFastSqrt(bodyA->dynamicFriction * bodyB->dynamicFriction);

  return manifold;
}

//==============================================================================
// Solve
//==============================================================================

void pxManifoldSolve(PxManifold *manifold) {
  // Detect collision between two bodies and populate the manifold with contacts
  pxCollide(manifold->bodyA, manifold->bodyB, manifold);
}

//==============================================================================
// Detect resting contacts
//==============================================================================

void pxManifoldDetectRestingContact(PxManifold *manifold, PxVec2 g, float dt) {
  if (manifold->contacts.length == 0) {
    return;
  }

  // Use minimum restitution for better stability in stacked objects
  float minRestitution =
      pxMin(manifold->bodyA->restitution, manifold->bodyB->restitution);

  // Check for resting contacts
  //
  // If relative velocity is less than what gravity would cause in one timestep,
  // we consider it a resting contact
  PxVec2 gravityStep = pxVec2Multf(g, dt);
  float gravityStepSqr = pxVec2LenSqr(gravityStep);

  PxBody *bodyA = manifold->bodyA;
  PxBody *bodyB = manifold->bodyB;

  for (uint8_t i = 0; i < manifold->contacts.length; i++) {
    // Calculate radii from COM to contact
    PxVec2 contact = manifold->contacts.items[i];
    PxVec2 ra = pxVec2Sub(contact, bodyA->position);
    PxVec2 rb = pxVec2Sub(contact, bodyB->position);

    // Calculate relative velocity at contact
    PxVec2 raPerp = pxVec2(-ra.y, ra.x);
    PxVec2 rbPerp = pxVec2(-rb.y, rb.x);

    PxVec2 va =
        pxVec2Add(bodyA->velocity, pxVec2Multf(raPerp, bodyA->angularVelocity));

    PxVec2 vb =
        pxVec2Add(bodyB->velocity, pxVec2Multf(rbPerp, bodyB->angularVelocity));

    PxVec2 rv = pxVec2Sub(vb, va);

    // Determine if this is a resting contact
    if (pxVec2LenSqr(rv) < gravityStepSqr + PX_EPSILON) {
      minRestitution = 0.0f;
      break;
    }
  }

  // Store the restitution for later use in impulse application
  manifold->mixedRestitution = minRestitution;
}

//==============================================================================
// Apply Impulse
//==============================================================================

void pxManifoldApplyImpulse(PxManifold *manifold) {
  if (!manifold->contacts.length) {
    return;
  }

  float mixedRestitution = manifold->mixedRestitution;

  PxBody *bodyA = manifold->bodyA;
  PxBody *bodyB = manifold->bodyB;

  // Skip if both bodies are static (have zero inverse mass)
  if (bodyA->iMass + bodyB->iMass <= 0) {
    return;
  }

  // Calculate radii from center of mass to contact
  for (uint8_t i = 0; i < manifold->contacts.length; i++) {
    PxVec2 contact = manifold->contacts.items[i];
    PxVec2 ra = pxVec2Sub(contact, bodyA->position);
    PxVec2 rb = pxVec2Sub(contact, bodyB->position);

    // Relative velocity at contact point
    PxVec2 raPerp = pxVec2(-ra.y, ra.x);
    PxVec2 rbPerp = pxVec2(-rb.y, rb.x);

    PxVec2 va =
        pxVec2Add(bodyA->velocity, pxVec2Multf(raPerp, bodyA->angularVelocity));

    PxVec2 vb =
        pxVec2Add(bodyB->velocity, pxVec2Multf(rbPerp, bodyB->angularVelocity));

    PxVec2 relativeVelocity = pxVec2Sub(vb, va);

    // Get velocity along the normal
    float velAlongNormal = pxVec2Dot(relativeVelocity, manifold->normal);

    // Skip if velocities are separating
    if (velAlongNormal > 0) {
      continue;
    }

    // Calculate cross products of radius vectors with normal
    // These determine how much the collision affects angular motion
    // Higher value = more torque applied from this contact point
    float raCrossN = pxVec2Cross(ra, manifold->normal);
    float rbCrossN = pxVec2Cross(rb, manifold->normal);

    float invMassSum = bodyA->iMass + bodyB->iMass +
                       raCrossN * raCrossN * bodyA->iMomentOfInertia +
                       rbCrossN * rbCrossN * bodyB->iMomentOfInertia;

    // Calculate impulse magnitude
    // Normal impulse formula: j = -(1+e)*vn / (invMassSum * contactCount)
    float normalImpulseMagnitude = -(1.0f + mixedRestitution) * velAlongNormal;
    float impulseDenom = invMassSum * manifold->contacts.length;
    float j = pxFastDiv(normalImpulseMagnitude, impulseDenom);

    // Apply normal impulse
    PxVec2 impulse = pxVec2Multf(manifold->normal, j);

    if (bodyA->iMass > 0) {
      pxBodyApplyImpulse(bodyA, pxVec2Neg(impulse), ra);
    }

    if (bodyB->iMass > 0) {
      pxBodyApplyImpulse(bodyB, impulse, rb);
    }

    // Friction impulse
    // Recalculate relative velocity after normal impulse is applied
    va =
        pxVec2Add(bodyA->velocity, pxVec2Multf(raPerp, bodyA->angularVelocity));

    vb =
        pxVec2Add(bodyB->velocity, pxVec2Multf(rbPerp, bodyB->angularVelocity));

    relativeVelocity = pxVec2Sub(vb, va);

    // Calculate tangent vector (perpendicular to normal)
    PxVec2 tangent = pxVec2Tangent(relativeVelocity, manifold->normal);

    // Check if tangent vector is non-zero
    float tangentLen = pxVec2Len(tangent);
    if (tangentLen > PX_EPSILON) {
      tangent = pxVec2Multf(tangent, pxFastRcp(tangentLen)); // Normalize
    } else {
      continue; // Skip friction for this contact
    }

    // Calculate friction impulse scalar
    // (jt = -vt / (invMassSum * contactCount))
    float tangentialVelocityMagnitude = -pxVec2Dot(relativeVelocity, tangent);
    float tangentialVelocityDenom = invMassSum * manifold->contacts.length;
    float jt = pxFastDiv(tangentialVelocityMagnitude, tangentialVelocityDenom);

    // Coulomb's law: friction force ≤ μ * normal force
    PxVec2 frictionImpulse;

    if (fabsf(jt) < j * manifold->staticFriction) {
      frictionImpulse = pxVec2Multf(tangent, jt); // Static friction
    } else {
      frictionImpulse = pxVec2Multf(
          tangent, -j * manifold->dynamicFriction); // Dynamic friction
    }

    // Apply friction impulse

    if (bodyA->iMass > 0) {
      pxBodyApplyImpulse(bodyA, pxVec2Neg(frictionImpulse), ra);
    }

    if (bodyB->iMass > 0) {
      pxBodyApplyImpulse(bodyB, frictionImpulse, rb);
    }
  }
}

void pxManifoldCorrectPosition(PxManifold *manifold) {
  // Skip correction if penetration is small or no contacts
  if (manifold->penetration <= PX_ALLOWED_PENETRATION ||
      manifold->contacts.length == 0) {
    return;
  }

  PxBody *bodyA = manifold->bodyA;
  PxBody *bodyB = manifold->bodyB;

  // Calculate correction based on inverse mass ratio
  float totalInvMass = bodyA->iMass + bodyB->iMass;

  if (totalInvMass <= PX_EPSILON) {
    return; // Both bodies are static
  }

  // Calculate positional correction:
  // 1. Find excess penetration beyond allowed limit
  float excessPenetration = manifold->penetration - PX_ALLOWED_PENETRATION;

  // 2. Scale by PX_POSITIONAL_CORRECTION_FACTOR (Baumgarte factor)
  // 3. Divide by total inverse mass to get impulse-like correction
  float correctionalMagnitude = pxFastDiv(
      excessPenetration * PX_POSITIONAL_CORRECTION_FACTOR, totalInvMass);

  PxVec2 correctionVector =
      pxVec2Multf(manifold->normal, correctionalMagnitude);

  // Apply position correction proportional to inverse mass
  if (bodyA->iMass > 0) {
    pxBodyMoveBy(bodyA, pxVec2Neg(pxVec2Multf(correctionVector, bodyA->iMass)));
  }

  if (bodyB->iMass > 0) {
    pxBodyMoveBy(bodyB, pxVec2Multf(correctionVector, bodyB->iMass));
  }
}

// Implementation from src/world.c



PxWorld *pxWorldAlloc(void) {
  PxWorld *world = (PxWorld *)pxalloc(sizeof(PxWorld));

  if (!world) {
    assert(0 && "Failed to allocate memory for PxWorld");
  }

  return world;
}

PxWorld *pxWorldInit(PxWorld *world, uint8_t iterations, uint8_t targetFps,
                     float scale) {
  world->iterations = iterations;
  world->scale = scale;
  world->staticBodies = (PxBodyArray){0};
  world->dynamicBodies = (PxBodyArray){0};
  world->contacts = (PxManifoldPool){0};

  // Default sleep settings
  world->linearSleepThresholdSq = 0.0001f; // 1cm/s
  world->angularSleepThreshold = 0.01f;    // ~0.6 degrees/s
  world->timeToSleep = 0.5f;               // half a second

  pxClockInit(&world->clock, targetFps);

  return world;
}

PxWorld *pxWorldNew(uint8_t iterations, uint8_t targetFps, float scale) {
  return pxWorldInit(pxWorldAlloc(), iterations, targetFps, scale);
}

void pxWorldFree(PxWorld *world) {
  if (!world) {
    return;
  }

  pxfree(world);
}

/**
 * @brief Adds a new body to the specified body array
 *
 * @param world
 * @param shape    - shape of the new body
 * @param density  - density of the new body (0 density = static body)
 * @param position - initial position of the new body
 *
 * @return PxBody* Pointer to the newly added body
 */
static PxBody *pxWorldAddBody(PxWorld *world, PxShape shape, float density,
                              PxVec2 position) {
  PxBody body = pxBodyNew(shape, density, position);

  // TODO: figure out how to generalize this better -
  // Scale restitution and friction
  body.restitution *= world->scale;
  body.staticFriction = pxFastDiv(body.staticFriction, world->scale);
  body.dynamicFriction = pxFastDiv(body.dynamicFriction, world->scale);

  PxBodyArray *bodies =
      density > 0 ? &world->dynamicBodies : &world->staticBodies;

  return pxBodyArrayAdd(bodies, &body);
}

PxBody *pxWorldNewStaticBody(PxWorld *world, PxShape shape, PxVec2 position) {
  PxBody *body = pxWorldAddBody(world, shape, 0, position);

  // Sort static bodies array when adding new body
  pxBodyArraySortByAxis(&world->staticBodies);

  return body;
}

PxBody *pxWorldNewDynamicBody(PxWorld *world, PxShape shape, float density,
                              PxVec2 position) {

  assert(density > 0 && "Dynamic bodies must have positive density");

  return pxWorldAddBody(world, shape, density, position);
}

void pxWorldFreeBody(PxWorld *world, PxBody *body) {
  if (!world || !body) {
    return;
  }

  PxBodyArray *bodies =
      body->density > 0 ? &world->dynamicBodies : &world->staticBodies;

  pxBodyArrayRemove(bodies, body->worldIndex);
}

//===============================================================================
// Physics calculations
//===============================================================================

static void pxDetectRestingContacts(PxWorld *world, PxVec2 g, float dt) {
  pxManifoldPoolEach(&world->contacts, manifold) {
    pxManifoldDetectRestingContact(manifold, g, dt);
  }
}

/**
 * @brief Updates sleep states for all dynamic bodies
 *
 * Bodies moving below the sleep threshold accumulate sleep time.
 * Bodies moving above the threshold are awakened.
 *
 * @param world
 * @param dt - time step in seconds
 */
static void pxUpdateSleepStates(PxWorld *world, float dt) {
  pxBodyArrayEach(&world->dynamicBodies, body) {
    bool isBelowThreshold =
        (pxVec2LenSqr(body->velocity) <= world->linearSleepThresholdSq) &&
        (fabsf(body->angularVelocity) <= world->angularSleepThreshold);

    if (isBelowThreshold) {
      body->sleepTime += dt;
    } else {
      pxBodyWakeUp(body);
    }
  }
}

/**
 * @brief Applies forces to bodies and updates their velocities
 *
 * Integrates external forces (including gravity) for dynamic bodies that are
 * not sleeping.
 *
 * @param world
 * @param g  - gravity vector
 * @param dt - time step in seconds
 */
static void pxIntegrateForces(PxWorld *world, PxVec2 g, float dt) {
  pxBodyArrayEach(&world->dynamicBodies, body) {
    // Skip sleeping bodies
    if (!body || body->sleepTime >= world->timeToSleep) {
      continue;
    }

    pxBodyIntegrateForces(body, g, dt);
  }
}

/**
 * @brief Resolves collisions by applying impulses
 *
 * Iterates through all contacts multiple times according to world->iterations
 * to resolve velocity constraints.
 *
 * @param world
 */
static void pxApplyImpulses(PxWorld *world) {
  for (uint8_t j = 0; j < world->iterations; j++) {
    pxManifoldPoolEach(&world->contacts, manifold) {
      pxManifoldApplyImpulse(manifold);
    }
  }
}

/**
 * @brief Updates positions of bodies based on their velocities
 *
 * Integrates velocities to determine new positions of dynamic bodies that are
 * not sleeping.
 *
 * @param world
 * @param dt - time step in seconds
 */
static void pxIntegrateVelocities(PxWorld *world, float dt) {
  pxBodyArrayEach(&world->dynamicBodies, body) {
    // Skip sleeping bodies
    if (body->sleepTime >= world->timeToSleep) {
      continue;
    }

    pxBodyIntegrateVelocity(body, dt);
  }
}

/**
 * @brief Corrects positions to prevent penetration
 *
 * Resolves position constraints by adjusting overlapping bodies.
 *
 * @param world
 */
static void pxCorrectPositions(PxWorld *world) {
  pxManifoldPoolEach(&world->contacts, manifold) {
    pxManifoldCorrectPosition(manifold);
  }
}

/**
 * @brief Resets forces on all dynamic bodies
 *
 * Clears accumulated forces and torques on dynamic bodies that are not
 * sleeping.
 *
 * @param world physics world
 */
static void pxClearForces(PxWorld *world) {
  pxBodyArrayEach(&world->dynamicBodies, body) {
    // Skip sleeping bodies (optional, depending on your design)
    if (body->sleepTime >= world->timeToSleep) {
      continue;
    }

    pxBodyClearForces(body);
  }
}

//==============================================================================
// Step
//==============================================================================

/**
 * @brief Performs collision detection between two bodies
 *
 * First checks AABB overlap, then performs detailed collision detection.
 * Creates a manifold if collision occurs and wakes up sleeping bodies.
 *
 * @param world
 * @param bodyA
 * @param bodyB
 */
static void pxDetectCollision(PxWorld *world, PxBody *bodyA, PxBody *bodyB) {
  // Only perform detailed collision if AABBs overlap
  if (!pxBodyAABBsOverlap(bodyA, bodyB)) {
    return;
  }

  // Debug - log collider types when both boxes (might be player vs ground)
  if (bodyA->collider.type == PX_POLYGON &&
      bodyB->collider.type == PX_POLYGON) {
  }

  PxManifold *manifold = pxManifoldPoolAcquire(&world->contacts);
  if (!manifold) {
    assert(0 && "Manifold pool exhausted");
  }

  pxManifoldInit(manifold, bodyA, bodyB);
  pxManifoldSolve(manifold);

  // Nothing collided, release the manifold
  if (manifold->contacts.length == 0) {
    if (bodyA->collider.type == PX_POLYGON &&
        bodyB->collider.type == PX_POLYGON) {
    }

    pxManifoldPoolReleaseLast(&world->contacts);
    return;
  }

  // Wake up bodies if they collide.
  // Only wake up a sleeping body if it collided with an awake one
  if (bodyA->sleepTime < world->timeToSleep) {
    pxBodyWakeUp(bodyB);
  }

  if (bodyB->sleepTime < world->timeToSleep) {
    pxBodyWakeUp(bodyA);
  }
}

/**
 * @brief Generates collision information for all potentially colliding pairs
 *
 * Implements a sweep and prune algorithm on the x-axis to efficiently find
 * potentially colliding body pairs.
 *
 * @param world
 */
static void pxGenerateCollisionInfo(PxWorld *world) {
  // Sort dynamic bodies by min x-coordinate (uses insertion sort)
  pxBodyArraySortByAxis(&world->dynamicBodies);

  // For each dynamic body
  pxBodyArrayEachWithIdx(&world->dynamicBodies, bodyA, idx) {
    // Skip sleeping vs sleeping collision checks,
    // but still check sleeping vs awake
    bool bodyASleeping = bodyA->sleepTime >= world->timeToSleep;

    float minX = bodyA->aabb.min.x;
    float maxX = bodyA->aabb.max.x;

    // Check against other dynamic bodies with potential overlap
    pxBodyArrayEachFrom(&world->dynamicBodies, idx + 1, bodyB) {
      // If both bodies are sleeping, skip this pair
      if (bodyASleeping && bodyB->sleepTime >= world->timeToSleep) {
        continue;
      }

      // Early exit when we've moved past possible collisions
      if (bodyB->aabb.min.x > maxX) {
        break;
      }

      pxDetectCollision(world, bodyA, bodyB);
    }

    // Binary search to find first static body that might collide
    uint8_t start = pxBodyArrayFindFirstIndexAfterX(&world->staticBodies, minX);

    // Check static bodies until we find one past our max X
    pxBodyArrayEachFrom(&world->staticBodies, start, bodyB) {
      // Early exit when we've moved past possible collisions
      if (bodyB->aabb.min.x > maxX) {
        break;
      }

      pxDetectCollision(world, bodyA, bodyB);
    }
  }
}

/**
 * @brief Advances the physics simulation by one time step
 *
 * The sequence of operations is:
 * 1. Clear existing contacts
 * 2. Detect new collisions
 * 3. Integrate forces (apply gravity and other forces)
 * 4. Solve velocity constraints (apply impulses)
 * 5. Integrate velocities (update positions)
 * 6. Correct positions (prevent penetration)
 * 7. Clear forces for next step
 *
 * @param world - physics world to update
 * @param g     - gravity vector
 * @param dt    - time step delta in seconds
 */
static void pxWorldStepWithDt(PxWorld *world, PxVec2 g, float dt) {
  pxManifoldPoolClear(&world->contacts);
  pxGenerateCollisionInfo(world);
  pxDetectRestingContacts(world, g, dt);
  pxIntegrateForces(world, g, dt);
  pxApplyImpulses(world);
  pxIntegrateVelocities(world, dt);
  pxCorrectPositions(world);
  pxUpdateSleepStates(world, dt);
  pxClearForces(world);
}

bool pxWorldStep(PxWorld *world, PxVec2 g) {
  PxClock *clock = &world->clock;
  bool stepped = false;
  uint8_t stepCount = 0;

  const int SUBSTEPS = 5;

  pxClockBeginFrame(clock);

  while (pxClockShouldStep(clock) && stepCount < clock->maxStepsPerFrame) {
    float substepDt =
        pxFastDiv(pxClockGetFixedDeltaTime(clock), SUBSTEPS) * world->scale;

    // Perform multiple substeps for each physics step
    for (int i = 0; i < SUBSTEPS; i++) {
      pxWorldStepWithDt(world, g, substepDt);
    }

    pxClockAdvance(clock);
    stepped = true;
    stepCount++;
  }

  // Log number of steps:
  pxlog("%d steps taken", stepCount);

  return stepped;
}

//==============================================================================
// Debug
//==============================================================================

void pxWorldDrawDebug(PxWorld *world) {
  // Track sleep statistics
  uint8_t sleepingCount = 0;
  uint8_t frozenCount = 0;

  // Draw AABBs for all bodies in the static array
  pxBodyArrayEach(&world->staticBodies, body) {
    PxAABB aabb = body->aabb;

    pd->graphics->drawRect(aabb.min.x, aabb.min.y, aabb.max.x - aabb.min.x,
                           aabb.max.y - aabb.min.y, kColorXOR);
  }

  // Draw AABBs for all bodies in the dynamic array
  pxBodyArrayEach(&world->dynamicBodies, body) {
    PxAABB aabb = body->aabb;

    // Draw AABB for all bodies
    pd->graphics->drawRect(aabb.min.x, aabb.min.y, aabb.max.x - aabb.min.x,
                           aabb.max.y - aabb.min.y, kColorXOR);

    // Get body velocity info
    float velLen = pxVec2Len(body->velocity);

    // Check if body is sleeping
    bool isSleeping = body->sleepTime >= world->timeToSleep;
    if (isSleeping) {
      sleepingCount++;

      // Draw Z on sleeping bodies
      float centerX = (aabb.min.x + aabb.max.x) / 2;
      float centerY = (aabb.min.y + aabb.max.y) / 2;

      pd->graphics->drawLine(centerX - 5, centerY - 5, centerX + 5, centerY - 5,
                             1, kColorBlack);
      pd->graphics->drawLine(centerX + 5, centerY - 5, centerX - 5, centerY + 5,
                             1, kColorBlack);
      pd->graphics->drawLine(centerX - 5, centerY + 5, centerX + 5, centerY + 5,
                             1, kColorBlack);
    }

    // Check for "frozen" bodies - nearly zero velocity but not enough sleep
    // time
    bool isNearlyStatic = (velLen < 0.001f);
    if (isNearlyStatic && !isSleeping) {
      frozenCount++;

      // Mark frozen bodies with a square
      float centerX = (aabb.min.x + aabb.max.x) / 2;
      float centerY = (aabb.min.y + aabb.max.y) / 2;
      float size = 4;

      pd->graphics->drawRect(centerX - size, centerY - size, size * 2, size * 2,
                             kColorXOR);
    }

    // Draw velocity vector (scaled for visibility)
    if (velLen > 0.01f) {
      float centerX = (aabb.min.x + aabb.max.x) / 2;
      float centerY = (aabb.min.y + aabb.max.y) / 2;
      pd->graphics->drawLine(centerX, centerY, centerX + body->velocity.x * 10,
                             centerY + body->velocity.y * 10, 1, kColorBlack);
    }
  }

  // Display statistics
  char *countText = NULL;
  int len = pd->system->formatString(
      &countText, "Contacts: %d  Sleeping: %d  Frozen: %d",
      world->contacts.length, sleepingCount, frozenCount);

  pd->graphics->drawText(countText, len, kASCIIEncoding, 5, 20);
}

// Implementation from src/clock.c



PxClock *pxClockInit(PxClock *clock, uint8_t targetFps) {
  if (!clock) {
    return NULL;
  }

  clock->maxStepsPerFrame = 3;
  clock->targetFps = pxClamp(targetFps <= 0 ? 50 : targetFps, 1, 50);
  clock->fixedTimestep = pxFastRcp(clock->targetFps);
  clock->lastUpdateMs = 0;
  clock->accumulator = 0;
  clock->isFirstUpdate = true;

  return clock;
}

void pxClockBeginFrame(PxClock *clock) {
  uint32_t currentTime = pd->system->getCurrentTimeMilliseconds();

  // Initialize on first update
  if (clock->isFirstUpdate) {
    clock->lastUpdateMs = currentTime;
    clock->isFirstUpdate = false;
    return;
  }

  // Calculate elapsed time since last frame
  uint32_t elapsed = currentTime - clock->lastUpdateMs;
  float frameTime = pxClamp(pxFastDiv(elapsed, 1000), 0, 0.1);

  // Add to accumulator and update last time
  clock->accumulator += frameTime;
  clock->lastUpdateMs = currentTime;
}

bool pxClockShouldStep(PxClock *clock) {
  return clock->accumulator >= clock->fixedTimestep;
}

float pxClockGetFixedDeltaTime(PxClock *clock) { return clock->fixedTimestep; }

void pxClockAdvance(PxClock *clock) {
  clock->accumulator -= clock->fixedTimestep;
}

void pxClockSetTargetFPS(PxClock *clock, uint8_t targetFps) {
  clock->targetFps = pxClamp(targetFps <= 0 ? 50 : targetFps, 1, 50);
  clock->fixedTimestep = pxFastRcp(clock->targetFps);
  clock->accumulator = 0;
}

// Implementation from src/polygon.c



/**
 * Creates polygon data from a set of vertices.
 *
 * @param vertices - array of vertex positions defining the polygon outline
 * @param count    - number of vertices in the array
 *
 * @return A PxPolygonData structure containing the processed polygon
 *         information
 */
PxPolygonData pxPolygonData(uint8_t count, PxVec2 *vertices) {
  // No hulls with less than 3 vertices (ensure actual polygon)
  assert(count > 2 && count <= PX_MAX_POLY_VERTEX_COUNT);

  PxPolygonData polygon = {0};

  // Find the right-most point on the hull (point with maximum x coordinate)
  // If tied, choose the one with the lowest y coordinate
  uint8_t rightMost = 0;
  float rightmostX = vertices[0].x;

  for (uint8_t i = 1; i < count; i++) {
    float x = vertices[i].x;

    if (x > rightmostX) {
      rightmostX = x;
      rightMost = i;
      continue;
    }

    // If x coordinates are equal, choose the lowest y-coordinate point
    // as this ensures a consistent rightmost point for the algorithm
    if (x == rightmostX && vertices[i].y < vertices[rightMost].y) {
      rightMost = i;
    }
  }

  // Implement convex hull algorithm (Graham scan variant)
  // We start from the rightmost point and find the convex hull
  // by selecting the most counter-clockwise points in sequence
  uint8_t hull[PX_MAX_POLY_VERTEX_COUNT];
  uint8_t outCount = 0;
  uint8_t indexHull = rightMost;

  while (true) {
    hull[outCount] = indexHull;

    // Search for the next index that wraps around the hull by computing cross
    // products to find the most counter-clockwise vertex in the set, given the
    // previous hull index
    uint8_t nextHullIndex = 0;

    for (uint8_t i = 1; i < count; i++) {
      // Skip if same coordinate as we need three unique points in the set to
      // perform a cross product
      if (nextHullIndex == indexHull) {
        nextHullIndex = i;
        continue;
      }

      // Cross every set of three unique vertices, recording each
      // counter-clockwise third vertex and add to the output hull

      PxVec2 e1 = pxVec2Sub(vertices[nextHullIndex], vertices[hull[outCount]]);
      PxVec2 e2 = pxVec2Sub(vertices[i], vertices[hull[outCount]]);

      float c = pxVec2Cross(e1, e2);

      if (c < 0) {
        nextHullIndex = i;
        continue;
      }

      // In case of collinear points (c == 0), pick point that's further away
      if (c == 0 && pxVec2LenSqr(e2) > pxVec2LenSqr(e1)) {
        nextHullIndex = i;
        continue;
      }
    }

    outCount++;
    indexHull = nextHullIndex;

    // Finish if we've gone full circle
    if (nextHullIndex == rightMost) {
      polygon.vertices.length = outCount;
      polygon.normals.length = outCount;
      break;
    }
  }

  // Copy vertices into shape's vertices and calculate maxRadius
  polygon.maxRadius = 0;
  for (uint8_t i = 0; i < polygon.vertices.length; i++) {
    PxVec2 vertex = vertices[hull[i]];
    pxVec2ArraySet(&polygon.vertices, i, vertex);

    float distSqr = pxVec2LenSqr(vertex);
    if (distSqr > polygon.maxRadius * polygon.maxRadius) {
      polygon.maxRadius = pxFastSqrt(distSqr);
    }
  }

  // Compute face normals
  for (uint8_t curIdx = 0; curIdx < polygon.normals.length; curIdx++) {
    uint8_t nextIdx = curIdx + 1 < polygon.normals.length ? curIdx + 1 : 0;

    PxVec2 face = pxVec2Sub(pxVec2ArrayGet(polygon.vertices, nextIdx),
                            pxVec2ArrayGet(polygon.vertices, curIdx));

    // Ensure no zero-length edges
    assert(pxVec2LenSqr(face) > PX_EPSILON * PX_EPSILON);

    // Calculate normal with 2D cross product between vector and scalar
    // Normal points outward from the polygon face
    PxVec2 normal = pxVec2(face.y, -face.x);
    pxVec2Normalize(&normal);
    pxVec2ArraySet(&polygon.normals, curIdx, normal);
  }

  return polygon;
}

/**
 * Computes mass properties for a polygon collider.
 *
 * @param collider - collider to compute mass properties for (must be a polygon
 *                   type)
 *
 * @param density  - material density in kg/m^2
 *
 * @return MassData structure containing mass, center of mass, and moment of
 *         inertia
 */
PxMassData pxPolygonComputeMass(PxCollider *collider, float density) {
  if (collider == NULL) {
    return (PxMassData){0};
  }

  // Calculate centroid and moment of interia
  PxVec2 centroid = pxVec2(0, 0);
  float area = 0;
  float momentOfInertia = 0;

  PxVec2Array vertices = collider->shape.polygon.vertices;

  for (uint8_t curIdx = 0; curIdx < vertices.length; curIdx++) {
    uint8_t nextIdx = curIdx + 1 < vertices.length ? curIdx + 1 : 0;

    // Triangle vertices, third vertex implied as (0, 0)
    PxVec2 curVertex = pxVec2ArrayGet(vertices, curIdx);
    PxVec2 nextVertex = pxVec2ArrayGet(vertices, nextIdx);

    float d = pxVec2Cross(curVertex, nextVertex);

    // Area of triangle formed with origin
    float triangleArea = 0.5f * d;
    area += triangleArea;

    // Use area to weight the centroid average, not just vertex position
    // Formula: (v1+v2)/3 * triangleArea (since the third vertex is at origin)
    pxVec2AddAssign(&centroid, pxVec2Multf(pxVec2Add(curVertex, nextVertex),
                                           triangleArea * PX_ONE_THIRD));

    // Calculate moment of inertia for the triangle using the standard physics
    // formula: ∫∫(x²+y²) dA = (1/12) * (x1²+x1*x2+x2²+y1²+y1*y2+y2²) * area
    float intx2 = curVertex.x * curVertex.x + nextVertex.x * curVertex.x +
                  nextVertex.x * nextVertex.x;

    float inty2 = curVertex.y * curVertex.y + nextVertex.y * curVertex.y +
                  nextVertex.y * nextVertex.y;

    momentOfInertia += (0.25f * PX_ONE_THIRD * d) * (intx2 + inty2);
  }

  // Normalize the centroid by the total area
  pxVec2MultfAssign(&centroid, pxFastRcp(area));

  // Translate vertices to centroid (make the centroid (0, 0)
  // This improves numerical stability and helps collision detection
  // by having the body rotate around its center of mass
  for (uint8_t i = 0; i < vertices.length; ++i) {
    pxVec2SubAssign(&vertices.items[i], centroid);
  }

  float mass = density * area;
  momentOfInertia = mass * momentOfInertia;

  return (PxMassData){
      .mass = mass,
      .iMass = pxFastSafeRcp(mass),
      .momentOfInertia = momentOfInertia,
      .iMomentOfInertia = pxFastSafeRcp(momentOfInertia),
  };
}

/**
 * Updates radius-based AABB for a polygon collider
 *
 * @param collider - polygon collider
 * @param position - current position of the body
 * @param outAABB  - AABB to update
 */
void pxPolygonUpdateAABB(PxCollider *collider, PxAABB *outAABB,
                         PxVec2 position) {
  float radius = collider->shape.polygon.maxRadius;
  outAABB->min = pxVec2Subf(position, radius);
  outAABB->max = pxVec2Addf(position, radius);
}

PxCollider pxPolygonColliderNew(PxVec2 vertices[], uint8_t count) {
  PxCollider collider = pxColliderNew(
      PX_POLYGON, (PxShapeData){.polygon = pxPolygonData(count, vertices)});

  collider.computeMass = &pxPolygonComputeMass;
  collider.updateAABB = &pxPolygonUpdateAABB;

  return collider;
}

PxCollider pxBoxColliderNew(float width, float height) {
  if (width <= 0.0f || height <= 0.0f) {
    return (PxCollider){0}; // Return invalid collider
  }

  const float halfWidth = width * 0.5f;
  const float halfHeight = height * 0.5f;

  PxVec2Array vertices = {
      .length = 4,
      .items =
          {
              pxVec2(-halfWidth, -halfHeight),
              pxVec2(halfWidth, -halfHeight),
              pxVec2(halfWidth, halfHeight),
              pxVec2(-halfWidth, halfHeight),
          },
  };

  PxVec2Array normals = {
      .length = 4,
      .items =
          {
              pxVec2(0, -1),
              pxVec2(1, 0),
              pxVec2(0, 1),
              pxVec2(-1, 0),
          },
  };

  // The maximum radius is the distance from center to a corner
  float maxRadius = pxFastSqrt(halfWidth * halfWidth + halfHeight * halfHeight);

  PxPolygonData polygon = {
      .vertices = vertices,
      .normals = normals,
      .maxRadius = maxRadius,
  };

  PxCollider collider =
      pxColliderNew(PX_POLYGON, (PxShapeData){.polygon = polygon});

  collider.computeMass = &pxPolygonComputeMass;
  collider.updateAABB = &pxPolygonUpdateAABB;

  return collider;
}

PxVec2 pxPolygonGetSupport(const PxPolygonData polygon,
                           const PxVec2 direction) {
  // Ensure direction is not zero
  if (pxVec2LenSqr(direction) < PX_EPSILON * PX_EPSILON) {
    return pxVec2(0, 0);
  }

  float bestProjection = -FLT_MAX;
  PxVec2 bestVertex = pxVec2ArrayGet(polygon.vertices, 0); // Safe default

  for (uint8_t i = 0; i < polygon.vertices.length; i++) {
    PxVec2 vertex = pxVec2ArrayGet(polygon.vertices, i);
    float projection = pxVec2Dot(vertex, direction);

    if (projection > bestProjection) {
      bestVertex = vertex;
      bestProjection = projection;
    }
  }

  return bestVertex;
}

// Implementation from src/collider.c

PxCollider pxColliderNew(PxColliderType type, PxShapeData shape) {
  return (PxCollider){.type = type, .shape = shape};
}

// Implementation from src/circle.c


/**
 * Computes mass properties for a circular collider.
 * This is primarily for internal use by the physics engine.
 *
 * @param collider - pointer to the circular collider
 * @param density  - mass density of the material (mass per unit area)
 *
 * @return Mass data including mass, inverse mass, moment of inertia and inverse
 *         moment
 */
PxMassData pxCircleComputeMass(PxCollider *collider, float density) {
  if (collider == NULL) {
    return (PxMassData){0};
  }

  float radius = collider->shape.circle.radius;
  float radiusSquared = radius * radius;

  // Calculate mass = π * r² * density
  float mass = PX_PI * radiusSquared * density;

  // Calculate moment of inertia = mass * r² = π * r⁴ * density
  float momentOfInertia = mass * radiusSquared;

  return (PxMassData){
      .mass = mass,
      .iMass = pxFastSafeRcp(mass), // Inverse mass (1/mass)
      .momentOfInertia = momentOfInertia,
      .iMomentOfInertia =
          pxFastSafeRcp(momentOfInertia), // Inverse moment of inertia
  };
}

/**
 * Updates AABB for a circle collider
 *
 * @param collider - circle collider
 * @param position - current position of the body
 * @param outAABB  - AABB to update
 */
void pxCircleUpdateAABB(PxCollider *collider, PxAABB *outAABB,
                        PxVec2 position) {
  float radius = collider->shape.circle.radius;
  outAABB->min = pxVec2Subf(position, radius);
  outAABB->max = pxVec2Addf(position, radius);
}

PxCollider pxCircleColliderNew(float radius) {
  PxCollider collider =
      pxColliderNew(PX_CIRCLE, (PxShapeData){.circle = {.radius = radius}});

  collider.computeMass = &pxCircleComputeMass;
  collider.updateAABB = &pxCircleUpdateAABB;

  return collider;
}

// Implementation from src/world_api.c



const PxWorldAPI *px_world;

/**
 * Constructor function to initialize the Body API.
 * Automatically called when the library is loaded.
 */
PxWorldAPI *newPxWorldAPI(void) {
  PxWorldAPI *api = pxalloc(sizeof(*px_world));

  if (api == NULL) {
    assert(0 && "Failed to allocate memory for PxWorldAPI");
  }

  // Initialize all function pointers
  api->new = &pxWorldNew;
  api->free = &pxWorldFree;
  api->newStaticBody = &pxWorldNewStaticBody;
  api->newDynamicBody = &pxWorldNewDynamicBody;
  api->freeBody = &pxWorldFreeBody;
  api->step = &pxWorldStep;
  api->drawDebug = &pxWorldDrawDebug;

  px_world = api;

  return api;
}

/**
 * Destructor function to clean up the Body API.
 * Automatically called when the library is unloaded.
 */
static void freePxWorldAPI(void) __attribute__((destructor));
static void freePxWorldAPI(void) { pxfree((void *)px_world); }

// Implementation from src/collision.c



/**
 * Detects and handles the collision between two circles.
 *
 * @param circleA  - first circle involved in the collision.
 * @param circleB  - second circle involved in the collision.
 * @param manifold - manifold to store collision information.
 */
static void pxCollideCircles(PxBody *circleA, PxBody *circleB,
                             PxManifold *manifold) {
  if (circleA == NULL || circleB == NULL || manifold == NULL) {
    return;
  }

  PxVec2 positionA = circleA->position;
  PxVec2 positionB = circleB->position;
  PxVec2 normal = pxVec2Sub(positionB, positionA);

  float radiusA = circleA->collider.shape.circle.radius;
  float radiusB = circleB->collider.shape.circle.radius;
  float combinedRadius = radiusA + radiusB;

  float distanceSquared = pxVec2LenSqr(normal);

  if (distanceSquared >= combinedRadius * combinedRadius) {
    manifold->contacts.length = 0;
    return;
  }

  float distance = pxFastSqrt(distanceSquared);

  if (distance < PX_EPSILON) {
    manifold->penetration = radiusA;
    manifold->normal = pxVec2(1, 0);
    manifold->contacts.length = 1;
    manifold->contacts.items[0] = positionA;
    return;
  }

  manifold->penetration = combinedRadius - distance;
  manifold->normal = pxVec2Divf(normal, distance);

  PxVec2 contact = pxVec2Add(positionA, pxVec2Multf(manifold->normal, radiusA));
  manifold->contacts.length = 1;
  manifold->contacts.items[0] = contact;
}

/**
 * Detects and handles the collision between a circle and a polygon.
 *
 * @param circle   - circle involved in the collision.
 * @param polygon  - polygon involved in the collision.
 * @param manifold - manifold to store collision information.
 */
static void pxCollideCirclePolygon(PxBody *cBody, PxBody *pBody,
                                   PxManifold *manifold) {

  if (cBody == NULL || pBody == NULL || manifold == NULL) {
    return;
  }

  manifold->contacts.length = 0;

  PxPolygonData polygon = pBody->collider.shape.polygon;
  PxCircleData circle = cBody->collider.shape.circle;

  // Transform circle center to polygon model space
  PxMat2 orientation = pBody->orientation;

  PxVec2 center = pxMat2MultVec2(pxMat2Transpose(orientation),
                                 pxVec2Sub(cBody->position, pBody->position));

  // Find edge with minimum penetration
  // Exact concept as using support points in polygon vs polygon
  float separation = -FLT_MAX;
  uint8_t faceNormalIdx = 0;

  for (uint8_t idx = 0; idx < polygon.vertices.length; idx++) {
    PxVec2 normal = pxVec2ArrayGet(polygon.normals, idx);
    PxVec2 vertex = pxVec2ArrayGet(polygon.vertices, idx);

    // Calculate separation between circle center and current vertex
    float s = pxVec2Dot(normal, pxVec2Sub(center, vertex));

    if (s > circle.radius) {
      return; // No collision
    }

    if (s > separation) {
      separation = s;
      faceNormalIdx = idx;
    }
  }

  // Check to see if center is within polygon
  if (separation < PX_EPSILON) {
    PxVec2 normal = pxVec2Neg(pxMat2MultVec2(
        orientation, pxVec2ArrayGet(polygon.normals, faceNormalIdx)));

    manifold->normal = normal;
    manifold->penetration = circle.radius;

    manifold->contacts.length = 1;
    manifold->contacts.items[0] =
        pxVec2Add(cBody->position, pxVec2Multf(normal, circle.radius));

    return;
  }

  // Grab face's vertices
  PxVec2 v1 = pxVec2ArrayGet(polygon.vertices, faceNormalIdx);
  PxVec2 v2 = pxVec2ArrayGet(
      polygon.vertices,
      faceNormalIdx + 1 < polygon.vertices.length ? faceNormalIdx + 1 : 0);

  float radiusSquared = circle.radius * circle.radius;
  manifold->penetration = circle.radius - separation;

  // Determine which voronoi region of the edge center of circle lies within
  float dot1 = pxVec2Dot(pxVec2Sub(center, v1), pxVec2Sub(v2, v1));

  // Closest to v1
  if (dot1 <= 0) {
    if (pxVec2DistSqr(center, v1) > radiusSquared) {
      return;
    }

    PxVec2 normal = pxMat2MultVec2(orientation, pxVec2Sub(v1, center));
    pxVec2Normalize(&normal);
    manifold->normal = normal;

    manifold->contacts.length = 1;
    manifold->contacts.items[0] =
        pxVec2Add(pxMat2MultVec2(orientation, v1), pBody->position);

    return;
  }

  float dot2 = pxVec2Dot(pxVec2Sub(center, v2), pxVec2Sub(v1, v2));

  // Closest to v2
  if (dot2 <= 0) {

    if (pxVec2DistSqr(center, v2) > radiusSquared) {
      return;
    }

    PxVec2 normal = pxMat2MultVec2(orientation, pxVec2Sub(v2, center));
    pxVec2Normalize(&normal);
    manifold->normal = normal;

    manifold->contacts.length = 1;
    manifold->contacts.items[0] =
        pxVec2Add(pxMat2MultVec2(orientation, v2), pBody->position);

    return;
  }

  // Closest to face
  PxVec2 normal = pxVec2ArrayGet(polygon.normals, faceNormalIdx);

  if (pxVec2Dot(pxVec2Sub(center, v1), normal) > circle.radius) {
    return;
  }

  normal = pxVec2Neg(pxMat2MultVec2(orientation, normal));
  manifold->normal = normal;

  manifold->contacts.length = 1;
  manifold->contacts.items[0] =
      pxVec2Add(cBody->position, pxVec2Multf(normal, circle.radius));
}

static float pxFindAxisLeastPenetration(uint8_t *faceIndex, PxBody *polyA,
                                        PxBody *polyB) {
  PxPolygonData polyDataA = polyA->collider.shape.polygon;
  PxPolygonData polyDataB = polyB->collider.shape.polygon;

  float bestDistance = -FLT_MAX;
  uint8_t bestIndex = 0;

  for (uint8_t i = 0; i < polyDataA.vertices.length; i++) {
    // Get face normal from A in world space
    PxVec2 n = pxVec2ArrayGet(polyDataA.normals, i);
    PxVec2 nw = pxMat2MultVec2(polyA->orientation, n);

    // Transform normal into B's model space
    PxMat2 buT = pxMat2Transpose(polyB->orientation);
    n = pxMat2MultVec2(buT, nw);

    // Get support point from B along -n
    PxVec2 s = pxPolygonGetSupport(polyDataB, pxVec2Neg(n));

    // Get vertex on face from A in B's model space
    PxVec2 v = pxVec2ArrayGet(polyDataA.vertices, i);
    v = pxVec2Add(pxMat2MultVec2(polyA->orientation, v), polyA->position);
    v = pxVec2Sub(v, polyB->position);
    v = pxMat2MultVec2(buT, v);

    // Compute penetration distance in B's model space
    float d = pxVec2Dot(n, pxVec2Sub(s, v));

    // Store greatest distance (least penetration)
    if (d > bestDistance) {
      bestDistance = d;
      bestIndex = i;
    }
  }

  *faceIndex = bestIndex;
  return bestDistance;
}

static void pxFindIncidentFace(PxVec2 v[2], PxBody *refPoly, PxBody *incPoly,
                               uint8_t referenceIndex) {
  PxPolygonData refPolyData = refPoly->collider.shape.polygon;
  PxPolygonData incPolyData = incPoly->collider.shape.polygon;

  // Get reference face normal in world space
  PxVec2 referenceNormal = pxVec2ArrayGet(refPolyData.normals, referenceIndex);
  referenceNormal = pxMat2MultVec2(refPoly->orientation, referenceNormal);

  // Transform to incident's model space
  PxVec2 incRefNormal =
      pxMat2MultVec2(pxMat2Transpose(incPoly->orientation), referenceNormal);

  // Find most anti-normal face on incident polygon
  int incidentFace = 0;
  float minDot = FLT_MAX;

  for (uint8_t i = 0; i < incPolyData.vertices.length; i++) {
    PxVec2 normal = pxVec2ArrayGet(incPolyData.normals, i);
    float dot = pxVec2Dot(incRefNormal, normal);

    if (dot < minDot) {
      minDot = dot;
      incidentFace = i;
    }
  }

  // Get incident face vertices in world space
  v[0] = pxVec2Add(
      incPoly->position,
      pxMat2MultVec2(incPoly->orientation,
                     pxVec2ArrayGet(incPolyData.vertices, incidentFace)));

  uint8_t nextVertex = (incidentFace + 1) % incPolyData.vertices.length;

  v[1] = pxVec2Add(
      incPoly->position,
      pxMat2MultVec2(incPoly->orientation,
                     pxVec2ArrayGet(incPolyData.vertices, nextVertex)));
}

static int pxClipSegmentToLine(PxVec2 out[2], const PxVec2 in[2], PxVec2 normal,
                               float offset) {
  // Output point count
  int sp = 0;

  // Calculate distances from each endpoint to the clip line
  float d1 = pxVec2Dot(normal, in[0]) - offset;
  float d2 = pxVec2Dot(normal, in[1]) - offset;

  // Points on opposite sides - calculate intersection point
  if (d1 * d2 < 0.0f) {
    // Calculate interpolation coefficient
    float alpha = d1 / (d1 - d2);

    // Calculate intersection point
    out[sp] = pxVec2Add(in[0], pxVec2Multf(pxVec2Sub(in[1], in[0]), alpha));
    sp++;
  }

  // Keep points behind the clip line (d <= 0)
  if (d2 <= 0.0f) {
    out[sp++] = in[1];
  }

  if (d1 <= 0.0f) {
    out[sp++] = in[0];
  }

  return sp;
}

/**
 * Detects and handles the collision between two polygons.
 *
 * @param polygonA - first polygon involved in the collision.
 * @param polygonB - second polygon involved in the collision.
 * @param manifold - manifold to store collision information.
 */
void pxCollidePolygons(PxBody *bodyA, PxBody *bodyB, PxManifold *manifold) {

  manifold->contacts.length = 0;

  // Check for a separating axis with A's face planes
  uint8_t faceA;
  float penetrationA = pxFindAxisLeastPenetration(&faceA, bodyA, bodyB);

  if (penetrationA >= 0.0f) {
    return; // Separation - no collision
  }

  // Check for a separating axis with B's face planes
  uint8_t faceB;
  float penetrationB = pxFindAxisLeastPenetration(&faceB, bodyB, bodyA);

  if (penetrationB >= 0.0f) {
    return; // Separation - no collision
  }

  // We have a collision. Determine which shape features to use.
  uint8_t referenceIndex;
  bool flip; // Always point from a to b

  PxBody *referenceBody; // Reference
  PxBody *incidentBody;  // Incident

  // Determine which shape contains reference face (deeper penetration)
  if (pxBiasGt(penetrationA, penetrationB)) {
    referenceBody = bodyA;
    incidentBody = bodyB;
    referenceIndex = faceA;
    flip = false;
  } else {
    referenceBody = bodyB;
    incidentBody = bodyA;
    referenceIndex = faceB;
    flip = true;
  }

  // World space incident face
  PxVec2 incidentFace[2];
  pxFindIncidentFace(incidentFace, referenceBody, incidentBody, referenceIndex);

  // Setup reference face vertices
  PxPolygonData refData = referenceBody->collider.shape.polygon;
  PxVec2 refFace[2];

  refFace[0] = pxVec2Add(
      referenceBody->position,
      pxMat2MultVec2(referenceBody->orientation,
                     pxVec2ArrayGet(refData.vertices, referenceIndex)));

  referenceIndex = (referenceIndex + 1) % refData.vertices.length;

  refFace[1] = pxVec2Add(
      referenceBody->position,
      pxMat2MultVec2(referenceBody->orientation,
                     pxVec2ArrayGet(refData.vertices, referenceIndex)));

  // Calculate reference face side normal in world space
  PxVec2 sidePlaneNormal = pxVec2Sub(refFace[1], refFace[0]);
  pxVec2Normalize(&sidePlaneNormal);

  // Orthogonalize
  PxVec2 refFaceNormal = pxVec2(-sidePlaneNormal.y, sidePlaneNormal.x);

  // Make sure reference face normal points outward
  if (flip) {
    pxVec2NegAssign(&refFaceNormal);
  }

  // ax + by = c (plane equation)
  // c is distance from origin
  float refC = pxVec2Dot(refFaceNormal, refFace[0]);

  // Compute negative side and positive side plane offsets
  float negSide = -pxVec2Dot(sidePlaneNormal, refFace[0]);
  float posSide = pxVec2Dot(sidePlaneNormal, refFace[1]);

  // Clip incident face to reference face side planes
  PxVec2 clipPoints1[2];
  PxVec2 clipPoints2[2];
  int cp; // Clipped points array

  // Clip against the first side plane
  cp = pxClipSegmentToLine(clipPoints1, incidentFace,
                           pxVec2Neg(sidePlaneNormal), negSide);

  if (cp < 2) {
    return; // Due to numerical issues, we don't have enough points
  }

  // Clip against the second side plane
  cp = pxClipSegmentToLine(clipPoints2, clipPoints1, sidePlaneNormal, posSide);

  if (cp < 2) {
    return; // Due to numerical issues, we don't have enough points
  }

  // Now clipPoints2 contains the clipped incident face points in world space

  // Set the collision normal
  manifold->normal = flip ? pxVec2Neg(refFaceNormal) : refFaceNormal;

  // Keep points behind reference face
  int numContacts = 0;

  // Check if points are behind reference face
  for (int i = 0; i < cp; i++) {
    float separation = pxVec2Dot(refFaceNormal, clipPoints2[i]) - refC;

    if (separation <= 0.0f) {
      manifold->contacts.items[numContacts] = clipPoints2[i];

      if (numContacts == 0) {
        manifold->penetration = -separation;
      } else {
        manifold->penetration += -separation;
      }

      numContacts++;

      // Safety check, shouldn't happen with only 2 inputs
      if (numContacts >= PX_MAX_CONTACTS) {
        break;
      }
    }
  }

  // Calculate average penetration if multiple points
  if (numContacts > 1) {
    manifold->penetration /= numContacts;
  }

  manifold->contacts.length = numContacts;
}

void pxCollide(PxBody *bodyA, PxBody *bodyB, PxManifold *manifold) {
  if (bodyA == NULL || bodyB == NULL || manifold == NULL) {
    return;
  }

  PxColliderType typeA = bodyA->collider.type;
  PxColliderType typeB = bodyB->collider.type;

  if (typeA == PX_CIRCLE && typeB == PX_POLYGON) {
    pxCollideCirclePolygon(bodyA, bodyB, manifold);
    return;
  }

  if (typeA == PX_CIRCLE && typeB == PX_CIRCLE) {
    pxCollideCircles(bodyA, bodyB, manifold);
    return;
  }

  if (typeA == PX_POLYGON && typeB == PX_CIRCLE) {
    pxCollideCirclePolygon(bodyB, bodyA, manifold);
    pxVec2NegAssign(&manifold->normal);
    return;
  }

  if (typeA == PX_POLYGON && typeB == PX_POLYGON) {
    pxCollidePolygons(bodyA, bodyB, manifold);
    return;
  }
}

// Implementation from src/manifold_pool.c

/**
 * @brief Clears the manifold pool.
 *
 * @param pool - pointer to the manifold pool.
 */
void pxManifoldPoolClear(PxManifoldPool *pool) { pool->length = 0; }

/**
 * @brief Acquires a new manifold from the pool.
 *
 * @param pool - pointer to the manifold pool.
 *
 * @return pointer to the acquired manifold, or NULL if the pool is exhausted.
 */
PxManifold *pxManifoldPoolAcquire(PxManifoldPool *pool) {
  if (pool->length >= PX_MAX_MANIFOLDS) {
    return NULL; // Pool is exhausted
  }

  return &pool->items[pool->length++];
}

/**
 * @brief Releases the most recently acquired manifold back to the pool.
 *
 * @param pool - pointer to the manifold pool.
 */
void pxManifoldPoolReleaseLast(PxManifoldPool *pool) {
  if (pool->length > 0) {
    pool->length--;
  }
}

// Implementation from src/body.c



PxBody pxBodyNew(PxShape shape, float density, PxVec2 position) {
  PxCollider collider;

  if (shape.box.width != 0 && shape.box.height != 0) {
    collider = pxBoxColliderNew(shape.box.width, shape.box.height);
  } else if (shape.circle.radius != 0) {
    collider = pxCircleColliderNew(shape.circle.radius);
  } else if (shape.polygon.vertexCount != 0) {
    collider =
        pxPolygonColliderNew(shape.polygon.vertices, shape.polygon.vertexCount);
  } else {
    return (PxBody){.isValid = false};
  }

  PxAABB aabb = {0};
  collider.updateAABB(&collider, &aabb, position);

  PxMassData massData =
      density > 0 ? collider.computeMass(&collider, density)
                  : (PxMassData){0}; // infer static body when density is 0

  if (density != 0 && (massData.mass <= 0 || massData.momentOfInertia <= 0)) {
    return (PxBody){.isValid = false};
  }

  return (PxBody){
      .aabb = aabb,
      .collider = collider,
      .density = density,
      .position = position,

      // Defaults
      .angularVelocity = 0,
      .dynamicFriction = 0.3,
      .staticFriction = 0.5,
      .restitution = 0.2,
      .torque = 0,

      // Initialize orientation to identity matrix
      .orientationAngle = 0,
      .orientation = pxMat2Identity(),

      // Initialize default vectors
      .velocity = pxVec2(0, 0),
      .force = pxVec2(0, 0),

      // Computed mass data
      .mass = massData.mass,
      .iMass = massData.iMass,
      .momentOfInertia = massData.momentOfInertia,
      .iMomentOfInertia = massData.iMomentOfInertia,

      // Initialize an "invalid" world index. This will be updated when the body
      // is added to a world.
      .worldIndex = PX_INVALID_WORLD_INDEX,

      .isValid = true,
  };
}

void pxBodySetPosition(PxBody *body, PxVec2 position) {
  if (!body) {
    return;
  }

  body->position = position;
  body->collider.updateAABB(&body->collider, &body->aabb, position);
}

void pxBodyMoveBy(PxBody *body, PxVec2 distance) {
  if (!body) {
    return;
  }

  pxVec2AddAssign(&body->position, distance);
  body->collider.updateAABB(&body->collider, &body->aabb, body->position);
}

void pxBodySetOrientation(PxBody *body, float radians) {
  if (!body) {
    return;
  }

  // Normalize angle to [0, 2π) range
  if ((radians = fmodf(radians, PX_2_PI)) < 0) {
    radians += PX_2_PI;
  }

  body->orientationAngle = radians;
  body->orientation = pxMat2Orientation(radians);
}

void pxBodyRotate(PxBody *body, float radians) {
  if (!body) {
    return;
  }

  pxBodySetOrientation(body, body->orientationAngle + radians);
}

bool pxBodyAABBsOverlap(PxBody *bodyA, PxBody *bodyB) {
  if (!bodyA || !bodyB || !bodyA->isValid || !bodyB->isValid) {
    return false;
  }

  PxAABB a = bodyA->aabb;
  PxAABB b = bodyB->aabb;

  // Check for separation on either axis
  if (a.max.x < b.min.x || a.min.x > b.max.x) {
    return false;
  }

  if (a.max.y < b.min.y || a.min.y > b.max.y) {
    return false;
  }

  // If not separated on either axis, they must overlap
  return true;
}

void pxBodyApplyImpulse(PxBody *body, PxVec2 impulse, PxVec2 contact) {
  pxVec2AddAssign(&body->velocity, pxVec2Multf(impulse, body->iMass));

  body->angularVelocity +=
      pxVec2Cross(contact, impulse) * body->iMomentOfInertia;

  // Only wake the body if impulse is significant
  float impulseSquaredMagnitude = pxVec2LenSqr(impulse);

  if (impulseSquaredMagnitude > PX_BODY_WAKE_THRESHOLD) {
    pxBodyWakeUp(body);
  }
}

void pxBodyApplyForce(PxBody *body, PxVec2 force, PxVec2 contact) {
  pxVec2AddAssign(&body->force, force);
  body->torque += pxVec2Cross(contact, force);

  pxBodyWakeUp(body);
}

void pxBodyIntegrateForces(PxBody *body, PxVec2 g, float dt) {
  if (body->iMomentOfInertia == 0) {
    return;
  }

  float halfDt = pxFastDiv(dt, 2);

  pxVec2AddAssign(
      &body->velocity,
      pxVec2Multf(pxVec2Add(pxVec2Multf(body->force, body->iMass), g), halfDt));

  body->angularVelocity += body->torque * body->iMomentOfInertia * halfDt;
}

void pxBodyIntegrateVelocity(PxBody *body, float dt) {
  if (body->iMomentOfInertia == 0) {
    return;
  }

  pxBodyMoveBy(body, pxVec2Multf(body->velocity, dt));
  pxBodyRotate(body, body->angularVelocity * dt);
}

void pxBodyClearForces(PxBody *body) {
  pxVec2Set(&body->force, 0, 0);
  body->torque = 0;
}

void pxBodyWakeUp(PxBody *body) { body->sleepTime = 0.0f; }

PxBody *pxBodyArrayAdd(PxBodyArray *array, PxBody *body) {
  if (!body->isValid) {
    return NULL;
  }

  /**
   * Memory management strategy for body array:
   *
   * - Bodies are stored in a contiguous array (array->items)
   *
   * - We maintain two tracking mechanisms:
   *
   *   1. activeIndices: Contains indices of all active bodies for efficient
   *                     iteration
   *
   *   2. freedIndices:  A stack of indices that have been freed and can be
   *                     reused
   *
   * - When adding a body, we prefer to reuse a freed index before extending the
   *   array
   *
   * - This approach allows O(1) addition/removal while maintaining memory
   *   locality
   */
  uint8_t index;

  if (array->freedCount > 0) {
    // Reuse a "freed" index
    index = array->freedIndices[--array->freedCount];
  } else if (array->length < PX_MAX_BODIES) {
    // Add to the end of the array (using current length as next index)
    index = array->length;
  } else {
    return NULL; // Array is full
  }

  // Update activeIndices and increment length.
  //
  // activeIndices maintains a list of indices that are currently in use.
  // This allows for efficient iteration through only active bodies.
  uint8_t currentLength = array->length;
  array->activeIndices[currentLength] = index;
  array->length++;

  // Store the world index on the body
  body->worldIndex = index;

  // Update the array
  array->items[index] = *body;

  // Return a pointer to the stored body
  return &array->items[index];
}

void pxBodyArrayRemove(PxBodyArray *array, uint8_t index) {
  if (index >= array->length || array->freedCount >= PX_MAX_BODIES) {
    return;
  }

  // Add the index to the freedIndices array
  array->freedIndices[array->freedCount++] = index;

  // Find the index in activeIndices and remove it by swapping with the last
  // element
  for (uint8_t i = 0; i < array->length; i++) {
    if (array->activeIndices[i] == index) {
      array->activeIndices[i] = array->activeIndices[--array->length];
      break;
    }
  }
}

/**
 * Sort a body array's activeIndices by the min X coordinate of each body's
 * AABB.
 *
 * This preserves body pointers since only the iteration order changes.
 *
 * @param bodies
 *
 * Note: Using insertion sort as it's efficient for small arrays (PX_MAX_BODIES
 *       is small) and performs well when data is already partially sorted.
 */
void pxBodyArraySortByAxis(PxBodyArray *bodies) {
  for (uint8_t i = 1; i < bodies->length; i++) {
    uint8_t currentActiveIndex = bodies->activeIndices[i];
    PxBody *currentBody = &bodies->items[currentActiveIndex];
    float currentMinX = currentBody->aabb.min.x;

    int j = i - 1;
    while (j >= 0) {
      uint8_t compareActiveIndex = bodies->activeIndices[j];
      PxBody *compareBody = &bodies->items[compareActiveIndex];

      if (compareBody->aabb.min.x <= currentMinX) {
        break;
      }

      bodies->activeIndices[j + 1] = bodies->activeIndices[j];
      j--;
    }

    bodies->activeIndices[j + 1] = currentActiveIndex;
  }
}

uint8_t pxBodyArrayFindFirstIndexAfterX(PxBodyArray *bodies, float minX) {
  if (bodies->length == 0) {
    return 0;
  }

  uint8_t low = 0;
  uint8_t high = bodies->length;

  while (low < high) {
    uint8_t mid = low + (high - low) / 2; // Prevents potential overflow
    uint8_t bodyIndex = bodies->activeIndices[mid];
    PxBody *body = &bodies->items[bodyIndex];

    if (!body || body->worldIndex == PX_INVALID_WORLD_INDEX) {
      // Handle invalid body (shouldn't happen if array is properly maintained)
      low = mid + 1;
      continue;
    }

    if (body->aabb.max.x < minX) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }

  return low;
}

// Implementation from src/body_api.c



const PxBodyAPI *px_body;

/**
 * Constructor function to initialize the Body API.
 * Automatically called when the library is loaded.
 */
PxBodyAPI *newPxBodyAPI(void) {
  PxBodyAPI *api = pxalloc(sizeof(*px_body));

  if (api == NULL) {
    assert(0 && "Failed to allocate memory for PxBodyAPI");
  }

  // Initialize all function pointers
  api->setOrientation = &pxBodySetOrientation;
  api->rotate = &pxBodyRotate;
  api->applyForce = &pxBodyApplyForce;
  api->applyImpulse = &pxBodyApplyImpulse;

  px_body = api;

  return api;
}

/**
 * Destructor function to clean up the Body API.
 * Automatically called when the library is unloaded.
 */
static void freePxBodyAPI(void) __attribute__((destructor));
static void freePxBodyAPI(void) { pxfree((void *)px_body); }

// Implementation from src/px_api.c

PlaydateAPI *pd = NULL;

PdPhyzxAPI *registerPdPhyzx(PlaydateAPI *playdate) {
  pd = playdate;

  PdPhyzxAPI *api = pxalloc(sizeof(*api));
  api->body = newPxBodyAPI();
  api->world = newPxWorldAPI();

  return api;
}


#endif // PDPHYZX_IMPLEMENTATION

#endif // PDPHYZX_H
